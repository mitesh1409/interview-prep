# Scopes - Global Scope, Function Scope, Block Scope, Lexical Scope, Scope Chain

**Scope** in JavaScript determines the accessibility of variables, functions, and objects in different parts of your code. It's the set of rules that governs where and how a variable can be looked up.

## What, Why, and How

| Aspect | Details |
| :--- | :--- |
| **What is it?** | The current context of execution, defining which variables and expressions are "visible" and accessible at a given point in the code. |
| **Why use it?** | **Security:** Variables defined inside a scope (e.g., a function) are protected from external access, preventing naming collisions and bugs. **Memory Management:** Variables can be garbage collected when they fall out of scope. |
| **How does it work?** | The JavaScript engine creates a **Lexical Environment** for each scope, establishing a hierarchical **Scope Chain** that determines lookup rules. |

## The Three Types of Scope

### 1\. Global Scope ðŸŒ

**What:** The outermost scope, accessible from anywhere in the JavaScript program. Variables declared outside of any function or block live here.

**Implication:**

* In a browser environment, the Global Scope is associated with the **`window`** object.
* Variables declared with `var` in the Global Scope become properties of the Global Object.
* It's best practice to minimize the use of Global Scope to prevent naming conflicts and memory clutter.

**Code Example:**

```javascript
// Global Scope
const globalMessage = "Hello World"; // Available everywhere

function checkGlobal() {
    console.log(globalMessage); // Accessing the global variable
}

console.log(globalMessage); // Output: Hello World
checkGlobal();              // Output: Hello World
```

### 2\. Function Scope (Local Scope) ðŸ§±

**What:** Variables declared inside a function are only accessible within that function and any nested functions inside it.

**Implication:**

* This is the traditional form of local scope in pre-ES6 JavaScript, primarily associated with the **`var`** keyword.
* Function scope provides data privacy; variables inside a function are invisible to the outside world.

**Code Example:**

```javascript
function calculateSum(a, b) {
    // Function Scope for `result` and `message`
    var result = a + b; 
    let message = "The sum is: ";
    console.log(message + result); // Accessible here
}

calculateSum(5, 10);
// console.log(result); // ReferenceError: result is not defined (outside of function scope)
```

### 3\. Block Scope (ES6+) ðŸ“¦

**What:** Variables declared with **`let`** and **`const`** inside a pair of curly braces (`{}`)â€”such as in `if` statements, `for` loops, or just standalone blocksâ€”are confined to that block.

**Implication:**

* This solved many of the issues caused by `var` leaking out of blocks (like `for` loops).
* `let` and `const` enable true block-level scoping, making code cleaner and more predictable.

**Code Example:**

```javascript
if (true) {
    // Block Scope for `x` and `y`
    let x = 10; 
    const y = 20; 
    var z = 30; // 'var' is NOT block-scoped! It leaks out.
    console.log(x); // Output: 10
}

// console.log(x); // ReferenceError: x is not defined (outside of block scope)

console.log(z); // Output: 30 (DANGER: var ignores block scope)
```

> Only let and const can be block scoped, var ignores block scope.

## The Scope Chain (The Lookup Mechanism)

The **Scope Chain** is the hierarchy of scopes that the JavaScript engine uses to look up variables.

* When the engine needs to resolve a variable, it starts by checking the **current scope**.
* If the variable is not found there, it moves up to the **immediate parent scope**.
* This process continues layer by layer until it reaches the **Global Scope**.
* If the variable is still not found in the Global Scope, a **`ReferenceError`** is thrown (unless running in non-strict mode where it might implicitly create a global variable).

**Code Example (Scope Chain):**

```javascript
const app = 'MyApp'; // Global Scope

function outerFunction() {
    const outerVar = 'Outer'; // Scope 1: Function Scope of outerFunction

    function innerFunction() {
        const innerVar = 'Inner'; // Scope 2: Function Scope of innerFunction
        
        // Lookup `app`: Checks Scope 2 -> Checks Scope 1 -> Finds in Global Scope
        console.log(app); 
        
        // Lookup `outerVar`: Checks Scope 2 -> Finds in Scope 1
        console.log(outerVar);
        
        // Lookup `innerVar`: Finds in Scope 2
        console.log(innerVar);
    }
    innerFunction();
}
outerFunction();
```

## ðŸ’¡ Summary / Key Takeaways

| Key Concept | Description |
| :--- | :--- |
| **Scope Definition** | The region of the code where a variable is accessible. |
| **`var`** | Is **Function-scoped** or **Global-scoped**. **Ignores** Block scope (`if`, `for` loops), leading to leakage. |
| **`let` and `const`** | Are **Block-scoped**. Recommended for most variable declarations as they contain variables safely within the nearest `{}` block. |
| **Scope Chain** | The hierarchical path the JS engine follows to look up a variable, moving outward from the current scope to the Global Scope. |

## ðŸ”— References

* **MDN Web Docs:** [Scope - JavaScript](https://developer.mozilla.org/en-US/docs/Glossary/Scope)
* **javascript.info:** [Variable Scope, Closure](https://www.google.com/search?q=https://javascript.info/var-let-const%23scope-summary)
* **YouTube Video:** Search for "JavaScript Scope and Scope Chain" for visual diagrams.

---

## Meaning of the word Lexical

The word **Lexical** relates to **words** or the **vocabulary** of a language. It comes from the Greek word *lexis*, meaning "word" or "phrase."

Here are a couple of simple statements explaining its meaning:

1. A **lexical** analysis of a text involves looking at the specific **words** used and their meaning, as opposed to the sentence structure.
2. In programming, **lexical scope** means that the accessibility of variables is determined by where the code (the words) is physically **written** in the file.
