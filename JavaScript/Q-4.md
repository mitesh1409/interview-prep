# Event Loop

The **Event Loop** is what allows JavaScript to handle asynchronous operations (like network requests or timers) without blocking the main thread, despite being single-threaded.

The **Event Loop** is not part of the JavaScript engine itself but is a core part of the browser or Node.js runtime environment. Its primary job is to monitor the **Call Stack** and the **Task Queue** (or Callback Queue) and push tasks from the queue onto the stack when the stack is empty. This non-blocking behavior is crucial for modern web applications.

## What, Why, and How

| Aspect | Details |
| :--- | :--- |
| **What is it?** | A constantly running process that checks if the Call Stack is empty and, if so, takes the next waiting **task** from the Task Queue and pushes it onto the stack for execution. |
| **Why use it?** | Because JavaScript is **single-threaded**, the Event Loop prevents **blocking**. It allows time-consuming operations (like fetching data) to be performed asynchronously, so the main thread remains free to handle user interface updates and other critical tasks. |
| **How does it work?** | It facilitates communication between the **Call Stack** (where synchronous code runs) and the **Task Queues** (where asynchronous results wait). |

## The Components of the Concurrency Model

Understanding the Event Loop requires knowing the three main components of the JavaScript Runtime:

1. **Call Stack:**
    * Where synchronous code is executed (one function at a time).
    * Must be **empty** for the Event Loop to proceed.
2. **Web APIs (or Node APIs):**
    * Features provided by the environment, not the JS engine itself (e.g., `setTimeout()`, `fetch()`, `DOM events`).
    * When an asynchronous function is called, it's passed to the relevant Web API for processing in the background.
3. **Task Queue (Callback Queue):**
    * Once a Web API finishes its background task (e.g., a timer expires or data is received), the corresponding **callback function** is placed here, waiting to be processed.

## The Event Loop in Action ðŸŽ¬

The Event Loop executes a very simple, continuous cycle:

1. **Run Sync Code:** The JavaScript engine executes all synchronous code. Function calls are pushed onto and popped off the **Call Stack**.
2. **Delegate Async:** When an asynchronous function (like `setTimeout`) is encountered, the callback is delegated to the **Web APIs** to run in the background. The function call itself is popped off the Call Stack, and the engine moves to the next synchronous instruction.
3. **Wait in Queue:** Once the Web API finishes its job, the asynchronous **callback** is moved from the Web API environment to the **Task Queue**.
4. **The Loop Check (The Magic):** The Event Loop constantly checks:
    * **Is the Call Stack Empty?** (No synchronous code is running).
    * **Is there a waiting callback in the Task Queue?**
5. **Push to Stack:** If the Call Stack is empty, the Event Loop takes the first callback from the Task Queue and **pushes it onto the Call Stack** for execution. This cycle ensures that asynchronous code only runs *after* all synchronous code has finished.

## Code Example Illustrating the Flow

```javascript
console.log('1. Start'); // Synchronous

setTimeout(function callbackA() {
    console.log('3. setTimeout callback'); // Async Macrotask
}, 0); // Timer expires immediately, but must wait in the Task Queue

console.log('2. End'); // Synchronous

// Execution Order and Call Stack Flow:
// 1. console.log('1. Start') runs and logs '1. Start'.
// 2. setTimeout is called. Its callbackA is passed to the Web API Timer.
// 3. console.log('2. End') runs and logs '2. End'.
// 4. Call Stack is now EMPTY.
// 5. The Event Loop checks the Task Queue. It finds callbackA.
// 6. callbackA is PUSHED onto the Call Stack.
// 7. callbackA runs and logs '3. setTimeout callback'.
// 8. callbackA returns and is POPPED off the stack.
// Final Output: 1. Start, 2. End, 3. setTimeout callback (Order is guaranteed)
```

## ðŸ’¡ Summary / Key Takeaways

| Key Concept | Description |
| :--- | :--- |
| **Purpose** | Enables **non-blocking** (asynchronous) behavior in single-threaded JavaScript. |
| **Single Thread** | JavaScript runs on one thread; only one task can be on the Call Stack at a time. |
| **Core Rule** | A callback from the Task Queue will **never** be executed until the **Call Stack is completely empty**. |
| **Main Players** | **Call Stack** (synchronous execution), **Web APIs** (asynchronous processing), and the **Task Queue** (waiting area for callbacks). |

## ðŸ”— References

* **MDN Web Docs:** [Concurrency model and Event Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) (The definitive resource).
* **javascript.info:** [Event Loop](https://javascript.info/event-loop)
* **YouTube Video:** Search for **"Philip Roberts What the heck is the event loop anyway?"** â€“ this is the most famous and essential talk on the subject.

---

## [What the heck is the "Event Loop" anyway?](https://www.youtube.com/watch?v=8aGhZQkoFbQ)

### #1 How does JavaScript work?

**What is JavaScript?**  
A Single-Threaded Non-Blocking Asynchronous Concurrent language.
I have a Call Stack, an Event Loop, a Callback Queue, some other APIs and stuff.

Lets have a look at the following terms:  

**Single-Threaded**  
There is only one main thread of execution.

**Non-Blocking**  
We should not block the main thread, Event Loop helps to ensure this by executing time consuming operations asynchronously.

**Synchronous**  
Executes code line by line, one after the other. Order of execution is guaranteed - top to bottom.
Main thread executes all the Synchronous code first.

**Asynchronous**  
Not Synchronous. Order of execution is not guaranteed. Execution is event based, happens in the background. Generally time consuming operations are executed asynchronously. Managed by "Event Loop".

**Concurrent**  
Concurrent means "existing or happening at the same time as something else".
Concurrency refers to performing different tasks simultaneously with differing goals.
Concurrency means doing multiple things at the same time or simultaneously,  
it is not parallelism.

### #2 What is Chrome Browser?

Philip: Hey V8, do you have a Call Stack, an Event Loop, a Callback Queue  
some other APIs and stuff?

V8: I have a Call Stack and a Heap. WTF are those other things?

Chrome Browser = V8 + Web APIs + Event Loop + Callback Queue

**V8**  

* Heap
    A place where memory allocation happens.
    A place/memory where variables, functions, objects etc. from our code are stored.
* Call Stack
    Keeps track of all the Execution Contexts.

**Web APIs**  

* DOM Events
* fetch, XMLHttpRequest
* setTimeout, setInterval

**Event Loop**  
Constantly monitors "Call Stack" & "Callback Queue" (or Task Queue).

**Callback Queue**  
Two types of queues:  

1. Microtask Queue/Priority Queue (gets high priority)  
2. Macrotask Queue/Task Queue

### #3 The Call Stack

one thread <=> one call stack <=> one thing at a time

Call Stack is a data structure which records basically where in the program we are.

JavaScript is a single threaded programming language.  
Which means it has a single call stack.  
And it can do one thing at a time, that's what a single thread means,  
the program can run one piece of code at a time.

Example - Normal Call Stack:  

```JavaScript
function multiply(num1, num2) {
    return num1 * num2;
}

function square(num) {
    return multiply(num, num);
}

function printSquare(num) {
    const squared = square(num);
    console.log(`Square of ${num} = ${squared}`);
}

printSquare(5);
```

---

Example - Call Stack with an Error:  

```JavaScript
function foo() {
    throw new Error('Something went wrong!');
}

function bar() {
    foo();
}

function baz() {
    bar();
}

baz();
```

This will print an error in the console with the following stack trace:  
Uncaught Error: Something went wrong!  
    at foo (<anonymous>:2:11)  
    at bar (<anonymous>:6:5)  
    at baz (<anonymous>:10:5)  
    at <anonymous>:13:1  

This is exactly the call stack as well.

---

Example - Blowing the Call Stack OR Stack Overflow:  

```JavaScript
function workHard() {
    workHard();
}

workHard();
```

It gives the following error:  
Uncaught RangeError: Maximum call stack size exceeded  
    at workHard (<anonymous>:2:5)  
    at workHard (<anonymous>:2:5)  
    at workHard (<anonymous>:2:5)  
    at workHard (<anonymous>:2:5)  
    at workHard (<anonymous>:2:5)  
    at workHard (<anonymous>:2:5)  
    at workHard (<anonymous>:2:5)  
    at workHard (<anonymous>:2:5)  
    at workHard (<anonymous>:2:5)  
    at workHard (<anonymous>:2:5)  

### #4 Blocking - What happens when things are slow?

We don't have any strict definition of Blocking or Non-Blocking code,  
but in general the code which takes longer is said to be Blocking.

Some examples of Blocking code are:

* Network/API calls
* setTimeout, setInterval
* DOM Events
* Image Processing
etc.

**Why is this a problem?**  
Because, browsers.

Browsers will get stuck if their main thread is blocked with time consuming operations.
They will become unresponsive, can't do anything until the main thread is free.
At the end this is not a good user experience.

**The solution?**  
Asynchronous callbacks.

### #5 Concurrency & The Event Loop

JavaScript's concurrency model is based on an Event Loop.

NOTE: setTimeout zero will defer the execution of its callback to the end of the call stack.

Example - setTimeout:  

```JavaScript
function hello(value) {
    console.log(`Hello ${value}`);
}

setTimeout(hello, 1000, 'One');
setTimeout(hello, 1000, 'Two');
setTimeout(hello, 1000, 'Three');
setTimeout(hello, 1000, 'Four');
```

setTimeout is not a guaranteed time to execution,  
it's a minimum time to execution.

Like setTimeout zero doesn't execute callback immediately,  
it will be executed once call stack is empty and its turn is reached.
