# Event Loop

The **Event Loop** is what allows JavaScript to handle asynchronous operations (like network requests or timers) without blocking the main thread, despite being single-threaded.

The **Event Loop** is not part of the JavaScript engine itself but is a core part of the browser or Node.js runtime environment. Its primary job is to monitor the **Call Stack** and the **Task Queue** (or Callback Queue) and push tasks from the queue onto the stack when the stack is empty. This non-blocking behavior is crucial for modern web applications.

## What, Why, and How

| Aspect | Details |
| :--- | :--- |
| **What is it?** | A constantly running process that checks if the Call Stack is empty and, if so, takes the next waiting **task** from the Task Queue and pushes it onto the stack for execution. |
| **Why use it?** | Because JavaScript is **single-threaded**, the Event Loop prevents **blocking**. It allows time-consuming operations (like fetching data) to be performed asynchronously, so the main thread remains free to handle user interface updates and other critical tasks. |
| **How does it work?** | It facilitates communication between the **Call Stack** (where synchronous code runs) and the **Task Queues** (where asynchronous results wait). |

## The Components of the Concurrency Model

Understanding the Event Loop requires knowing the three main components of the JavaScript Runtime:

1. **Call Stack:**
    * Where synchronous code is executed (one function at a time).
    * Must be **empty** for the Event Loop to proceed.
2. **Web APIs (or Node APIs):**
    * Features provided by the environment, not the JS engine itself (e.g., `setTimeout()`, `fetch()`, `DOM events`).
    * When an asynchronous function is called, it's passed to the relevant Web API for processing in the background.
3. **Task Queue (Callback Queue):**
    * Once a Web API finishes its background task (e.g., a timer expires or data is received), the corresponding **callback function** is placed here, waiting to be processed.

## The Event Loop in Action ðŸŽ¬

The Event Loop executes a very simple, continuous cycle:

1. **Run Sync Code:** The JavaScript engine executes all synchronous code. Function calls are pushed onto and popped off the **Call Stack**.
2. **Delegate Async:** When an asynchronous function (like `setTimeout`) is encountered, the callback is delegated to the **Web APIs** to run in the background. The function call itself is popped off the Call Stack, and the engine moves to the next synchronous instruction.
3. **Wait in Queue:** Once the Web API finishes its job, the asynchronous **callback** is moved from the Web API environment to the **Task Queue**.
4. **The Loop Check (The Magic):** The Event Loop constantly checks:
    * **Is the Call Stack Empty?** (No synchronous code is running).
    * **Is there a waiting callback in the Task Queue?**
5. **Push to Stack:** If the Call Stack is empty, the Event Loop takes the first callback from the Task Queue and **pushes it onto the Call Stack** for execution. This cycle ensures that asynchronous code only runs *after* all synchronous code has finished.

## Code Example Illustrating the Flow

```javascript
console.log('1. Start'); // Synchronous

setTimeout(function callbackA() {
    console.log('3. setTimeout callback'); // Async Macrotask
}, 0); // Timer expires immediately, but must wait in the Task Queue

console.log('2. End'); // Synchronous

// Execution Order and Call Stack Flow:
// 1. console.log('1. Start') runs and logs '1. Start'.
// 2. setTimeout is called. Its callbackA is passed to the Web API Timer.
// 3. console.log('2. End') runs and logs '2. End'.
// 4. Call Stack is now EMPTY.
// 5. The Event Loop checks the Task Queue. It finds callbackA.
// 6. callbackA is PUSHED onto the Call Stack.
// 7. callbackA runs and logs '3. setTimeout callback'.
// 8. callbackA returns and is POPPED off the stack.
// Final Output: 1. Start, 2. End, 3. setTimeout callback (Order is guaranteed)
```

## ðŸ’¡ Summary / Key Takeaways

| Key Concept | Description |
| :--- | :--- |
| **Purpose** | Enables **non-blocking** (asynchronous) behavior in single-threaded JavaScript. |
| **Single Thread** | JavaScript runs on one thread; only one task can be on the Call Stack at a time. |
| **Core Rule** | A callback from the Task Queue will **never** be executed until the **Call Stack is completely empty**. |
| **Main Players** | **Call Stack** (synchronous execution), **Web APIs** (asynchronous processing), and the **Task Queue** (waiting area for callbacks). |

## ðŸ”— References

* **MDN Web Docs:** [Concurrency model and Event Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) (The definitive resource).
* **javascript.info:** [Event Loop](https://javascript.info/event-loop)
* **YouTube Video:** Search for **"Philip Roberts What the heck is the event loop anyway?"** â€“ this is the most famous and essential talk on the subject.
