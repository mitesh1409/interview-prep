# Prototype & Prototype Chain

**Prototype** meaning  
A prototype is an early, functional model of a product used to test a concept and gather feedback before final development. It can be as simple as a paper sketch or a basic, clickable digital version, and helps identify flaws and refine the design before investing significant time and resources. Think of it as a working draft or a "rough draft" of an idea to see if it works.

We will check Prototype and Prototype Chain of the following:  

* POJOs (Plain Old JavaScript Objects)
* Classes
* Functions

## Prototype Chain for a POJO

POJOs are created using object literals or `Object.create(null)` syntax.

When you create the `spiderMan` object using the object literal syntax `{}`, JavaScript automatically links it to the fundamental, built-in `Object.prototype`.

Example  

```JavaScript
// Prototype Chain for POJOs (Plain Old JavaScript Objects)

const spiderMan = {
    firstName: 'Peter',
    lastName: 'Parker',
    superheroName: 'Spider Man',
    from: 'New York',
    dob: '2003-12-05',

    greet() {
        console.log(`Hello I am ${this.firstName} from ${this.from}. How are you?`);
    },

    fight() {
        console.log(`${this.superheroName} in action...`);
    }
};

const ironMan = {
    firstName: 'Tony',
    lastName: 'Stark',
    superheroName: 'Iron Man',
    from: 'California',
    dob: '1985-10-25',

    greet() {
        console.log(`Hello I am ${this.firstName} from ${this.from}. How are you?`);
    },

    fight() {
        console.log(`${this.superheroName} in action...`);
    }
};

console.log('spiderMan');
console.log(spiderMan); // This is an object literal.
console.log(spiderMan.__proto__); // It points to Object.prototype (end of the prototype chain).
console.log(spiderMan.__proto__.__proto__); // The prototype of Object.prototype is null, which marks the absolute end of the prototype chain.

console.log("spiderMan's Prototype");
console.log(
    Object.getPrototypeOf(spiderMan)
);
console.log("spiderMan's Prototype's Prototype");
console.log(
    Object.getPrototypeOf(
        Object.getPrototypeOf(spiderMan)
    )
);

console.log('ironMan');
console.log(ironMan); // This is an object literal.
console.log(ironMan.__proto__); // It points to Object.prototype (end of the prototype chain).
console.log(ironMan.__proto__.__proto__); // The prototype of Object.prototype is null, which marks the absolute end of the prototype chain.

console.log("ironMan's Prototype");
console.log(
    Object.getPrototypeOf(ironMan)
);
console.log("ironMan's Prototype's Prototype");
console.log(
    Object.getPrototypeOf(
        Object.getPrototypeOf(ironMan)
    )
);
```

**Prototype Chain**  

`spiderMan` $\rightarrow$ `Object.prototype` $\rightarrow$ `null`  
`ironMan` $\rightarrow$ `Object.prototype` $\rightarrow$ `null`  

### 1\. The Instance Object

* **Object:** `spiderMan`
* **Properties:** It holds its own unique properties (`firstName`, `lastName`, `from`, `dob`, `greet`, `fight`).

### 2\. The First Prototype Link (The Parent)

The `spiderMan` object's internal prototype link `__proto__` points directly to the generic JavaScript **`Object.prototype`**.

```javascript
console.log(spiderMan.__proto__);
// It points to Object.prototype (end of the prototype chain).
```

**`Object.prototype`** contains all the essential methods that nearly every JavaScript object inherits, such as:

* `toString()`
* `hasOwnProperty()`
* `isPrototypeOf()`
* `valueOf()`

### 3\. The End of the Chain

The prototype of `Object.prototype` is **`null`**, which marks the absolute end of the prototype chain.

```javascript
console.log(spiderMan.__proto__.__proto__); 
// The prototype of Object.prototype is null, which marks the absolute end of the prototype chain.
```

If you try to access a method that doesn't exist on `spiderMan` (e.g., `spiderMan.fly()`), the engine will:

1. Check `spiderMan`.
2. Check `Object.prototype`.
3. Check `null` and return `undefined`.

**Conclusion:** A POJO created via object literal inherits directly from the global **`Object.prototype`**, making it the second link in its chain, and `null` the final link.

## Prototype Chain for a Class

Example  

```JavaScript
// Prototype Chain for Classes

class SuperHero {
    constructor(firstName, lastName, superheroName, from, dob) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.superheroName = superheroName;
        this.from = from;
        this.dob = dob;
    }

    greet() {
        console.log(`Hello I am ${this.firstName} from ${this.from}. How are you?`);
    }

    fight() {
        console.log(`${this.superheroName} in action...`);
    }
};

const spiderMan = new SuperHero('Peter', 'Parker', 'Spider Man', 'New York', '2003-12-05');
const ironMan = new SuperHero('Tony', 'Stark', 'Iron Man', 'California', '1985-10-25');

console.log(spiderMan); // This is an object of SuperHero class.
console.log(spiderMan.__proto__); // SuperHero.prototype, this contains all the methods of the SuperHero class.
console.log(spiderMan.__proto__.__proto__); // It points to Object.prototype (end of the prototype chain).
console.log(spiderMan.__proto__.__proto__.__proto__); // The prototype of Object.prototype is null, which marks the absolute end of the prototype chain.
```

**Prototype Chain**  

`SuperHero` $\rightarrow$ `SuperHero.prototype` $\rightarrow$ `Object.prototype` $\rightarrow$ `null`  

## Prototype Chain for a Function

Example  

```JavaScript
// Prototype Chain for Functions

function SuperHero(firstName, lastName, superheroName, from, dob) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.superheroName = superheroName;
    this.from = from;
    this.dob = dob;

    this.greet = function() {
        console.log(`Hello I am ${this.firstName} from ${this.from}. How are you?`);
    };

    this.fight = function() {
        console.log(`${this.superheroName} in action...`);
    };
}

SuperHero.prototype.smile = function() {
    console.log(':)');
}

const spiderMan = new SuperHero('Peter', 'Parker', 'Spider Man', 'New York', '2003-12-05');
const ironMan = new SuperHero('Tony', 'Stark', 'Iron Man', 'California', '1985-10-25');

console.log(spiderMan); // This is an object created using SuperHero constructor function.
console.log(spiderMan.__proto__); // SuperHero.prototype, contains methods directly linked to this prototype. Prototype object contains shared methods across all the objects, methods inside the function are not shared across all the objects, they are created every time a new instance is created. That is why to avoid code duplication it makes a perfect sense to define them in the prototype and inherit them that way.
console.log(spiderMan.__proto__.__proto__); // It points to Object.prototype (end of the prototype chain).
console.log(spiderMan.__proto__.__proto__.__proto__); // The prototype of Object.prototype is null, which marks the absolute end of the prototype chain.
```

**Prototype Chain**  

`SuperHero` $\rightarrow$ `SuperHero.prototype` $\rightarrow$ `Object.prototype` $\rightarrow$ `null`

---

**Prototypes** and the **Prototype Chain** are foundational to object-oriented programming in JavaScript.

### Prototypes and the Prototype Chain

JavaScript uses a **prototype-based inheritance model**, meaning objects inherit properties and methods from other objects. **Prototypes** are the mechanism by which this inheritance is achieved.

### What is a Prototype?

| Aspect | Details |
| :--- | :--- |
| **What is it?** | A plain object (the prototype object) that another object uses as a blueprint for inheriting properties and methods. |
| **How to Access it?** | Every object in JavaScript has an internal property, accessible via `Object.getPrototypeOf(obj)` or, historically and less commonly, the non-standard `obj.__proto__`. |
| **Function Role** | Every function (including constructor functions) automatically gets a special property called **`prototype`** (not to be confused with the internal `__proto__` link). Objects created via `new FunctionName()` automatically get linked to `FunctionName.prototype`. |

### Code Example: Creating and Inheriting

```javascript
// 1. Define a Constructor Function
function Vehicle(make) {
    this.make = make;
}

// 2. Add a method to the constructor's prototype
Vehicle.prototype.startEngine = function() {
    console.log(`The ${this.make} engine is starting.`);
};

// 3. Create a new object instance
const car = new Vehicle('Honda');

// The instance 'car' does not have 'startEngine' directly, but inherits it
car.startEngine(); // Output: The Honda engine is starting.

// Accessing the internal prototype link
console.log(Object.getPrototypeOf(car) === Vehicle.prototype); // Output: true
```

---

### The Prototype Chain: The Inheritance Link

The **Prototype Chain** is the hierarchy of links between objects that determines the inheritance path.

### How the Chain Works

1. When you try to access a property or method on an object (e.g., `car.make` or `car.startEngine()`), the JavaScript engine first checks if the property exists **directly** on the object itself.
2. If it doesn't find the property there, it follows the internal **`[[Prototype]]` link** (the `__proto__` link) to the object's prototype.
3. It checks the prototype object for the property.
4. If it still isn't found, it follows the prototype's own `[[Prototype]]` link up the chain.
5. This continues until it reaches the end of the chain, which is always **`Object.prototype`**.
6. The prototype of `Object.prototype` is **`null`**, which terminates the chain. If the property is not found anywhere, the result is `undefined`.

### Code Example: Traversing the Chain

```javascript
// Function Constructor
function Animal(name) {
    this.name = name;
}
Animal.prototype.speak = function() { return `${this.name} makes a sound.`; };

// Inheriting Constructor (ES5 style)
function Dog(name, breed) {
    Animal.call(this, name);
    this.breed = breed;
}
Dog.prototype = Object.create(Animal.prototype); // 1. Link Dog's prototype to Animal's prototype

const rex = new Dog('Rex', 'Shepherd');

// Prototype Chain Lookup for rex.toString:
// 1. Is toString on 'rex'? No.
// 2. Follow __proto__ to Dog.prototype. Is toString here? No.
// 3. Follow Dog.prototype's __proto__ to Animal.prototype. Is toString here? No.
// 4. Follow Animal.prototype's __proto__ to Object.prototype. Is toString here? YES!
console.log(rex.toString()); // Inherits from Object.prototype
```

**Chain:** `rex` $\rightarrow$ `Dog.prototype` $\rightarrow$ `Animal.prototype` $\rightarrow$ `Object.prototype` $\rightarrow$ `null`

### Relationship with Classes (ES6)

ES6 **Classes** are primarily **syntactical sugar** over the prototype-based inheritance model. The `extends` and `super` keywords simply automate the complex linkage necessary to set up the prototype chain correctly.

**ES6 Class Example:**

```javascript
class Animal {
    // ...
}
class Dog extends Animal { // Internally sets Dog.prototype to inherit from Animal.prototype
    // ...
}
```

The underlying mechanism is still the prototype chain.

---

### ðŸ’¡ Summary / Key Takeaways

| Key Concept | Description |
| :--- | :--- |
| **Prototype** | An object serving as a template; an instance object is linked to it via the internal `[[Prototype]]` property. |
| **Prototype Chain** | The sequence of linked objects that the JS engine traverses to look up properties and methods, providing inheritance. |
| **Lookup Rule** | Properties are searched directly on the object, then up the chain, until `Object.prototype` (and then `null`) is reached. |
| **ES6 Classes** | They are syntactic sugar; they use the **Prototype Chain** under the hood to manage inheritance. |

---

### ðŸ”— References

* **MDN Web Docs:** [Inheritance and the prototype chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
* **javascript.info:** [Prototypal inheritance](https://javascript.info/prototype-inheritance)
* **YouTube Video:** Search for "JavaScript Prototypes and Prototype Chain" for visual diagrams.
