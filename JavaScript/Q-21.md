# Memoization

Memoization in JavaScript is an optimization technique used to speed up applications by caching the results of expensive function calls and returning the cached result when the same inputs occur again. This reduces redundant computations and improves performance, especially for functions that are called repeatedly with the same arguments.

## How Memoization Works

* **Cache Storage:** A memoized function maintains a cache (often an object or Map) to store the results of previous function calls.
* **Input Check:** When the memoized function is called, it first checks if the result for the given inputs already exists in the cache.
* **Return Cached Result:** If a cached result is found for the current inputs, it is immediately returned, avoiding the execution of the original function.
* **Execute and Cache:** If the result is not in the cache, the original function is executed, and its return value is stored in the cache, associated with the corresponding inputs, before being returned.

## Example

**Example #1**  

```JavaScript
function memoize(func) {
    const cacheStorage = new Map();

    return function(...args) {
        const inputKey = JSON.stringify(...args);
        const cachedResult = cacheStorage.get(inputKey);
        if (cachedResult) {
            return cachedResult;
        }

        const output = func(...args);
        cacheStorage.set(inputKey, output);
        return output;
    }
};

function double(n) {
    // Delay to stimulate that this function is doing heavy/time-consuming operations.
    for (let i = 0; i < 1000000000; i++) {}
    return n * 2;
}

// Without Memoization

console.time('double');
console.log(double(50));
console.timeEnd('double');

console.time('double');
console.log(double(50));
console.timeEnd('double');

console.time('double');
console.log(double(50));
console.timeEnd('double');

console.time('double');
console.log(double(50));
console.timeEnd('double');

console.time('double');
console.log(double(50));
console.timeEnd('double');

// With Memoization

const memoDouble = memoize(double);

console.time('memoDouble');
console.log(memoDouble(50));
console.timeEnd('memoDouble');

console.time('memoDouble');
console.log(memoDouble(50));
console.timeEnd('memoDouble');

console.time('memoDouble');
console.log(memoDouble(50));
console.timeEnd('memoDouble');

console.time('memoDouble');
console.log(memoDouble(50));
console.timeEnd('memoDouble');

console.time('memoDouble');
console.log(memoDouble(50));
console.timeEnd('memoDouble');
```

**Example #2**  

```JavaScript
const N = 45;

// Without Memoization
function generateNthFibonacci(n) {
    if (n <= 0) {
        throw Error('Invalid argument: give a positive number');
    }

    const first = 0;
    const second = 1;

    if (n === 1) {
        return first;
    }

    if (n === 2) {
        return second;
    }

    return generateNthFibonacci(n-1) + generateNthFibonacci(n-2);
}

console.log('Without Memoization');

console.time('fibonacci');
console.log(`Fibonacci #${N} = ${generateNthFibonacci(N)}`);
console.timeEnd('fibonacci');

console.time('fibonacci');
console.log(`Fibonacci #${N} = ${generateNthFibonacci(N)}`);
console.timeEnd('fibonacci');

console.time('fibonacci');
console.log(`Fibonacci #${N} = ${generateNthFibonacci(N)}`);
console.timeEnd('fibonacci');

console.log('==============================');

// Each of them takes around 4254ms

// With Memoization
function fibonacci(n) {
    if (n <= 0) {
        throw Error('Invalid argument: give a positive number');
    }

    const first = 0;
    const second = 1;

    if (n === 1) {
        return first;
    }

    if (n === 2) {
        return second;
    }

    return memoFibonacci(n-1) + memoFibonacci(n-2);
}

function memoize(func) {
    const cacheStorage = new Map();

    return function(...args) {
        const inputKey = JSON.stringify(...args);
        const cachedResult = cacheStorage.get(inputKey);
        if (cachedResult) {
            return cachedResult;
        }

        const output = func(...args);
        cacheStorage.set(inputKey, output);
        return output;
    }
};

const memoFibonacci = memoize(fibonacci);

console.log('With Memoization');

console.time('memoFibonacci');
console.log(`Fibonacci #${N} = ${memoFibonacci(N)}`);
console.timeEnd('memoFibonacci');

console.time('memoFibonacci');
console.log(`Fibonacci #${N} = ${memoFibonacci(N)}`);
console.timeEnd('memoFibonacci');

console.time('memoFibonacci');
console.log(`Fibonacci #${N} = ${memoFibonacci(N)}`);
console.timeEnd('memoFibonacci');

// It takes around 0.116943359375ms first time, repeated calls take around 0.009ms
```

## Key Benefits

Performance Improvement: Reduces execution time by avoiding redundant calculations.
Resource Optimization: Efficiently utilizes CPU and memory by reusing computed results.

## Considerations

* **Pure Functions:** Memoization is most effective with pure functions, which always produce the same output for the same input and have no side effects.
* **Argument Complexity:** Creating unique keys for complex arguments (objects, arrays) can be challenging and might require deep comparison logic.
* **Cache Management:** For long-running applications, consider strategies to manage cache size and potentially clear outdated entries.

## Memoization - What, Why, How

**What?**  
It is an optimization technique, where we cache the results of a function call against its input parameters.  
So when the same function is called again with the same parameters we return results from the cache.  
That way we save repeatedly occuring costly operations/calculations.  

Memoization technique is useful for the functions which are called repeatedly and do heavy operations/calcuations.  

**Why?**  
We may have functions in our application that do heavy computation work and are called repeatedly.  
In that case each time function is called we do computation again and again.  
Here we are doing redundant calculations.  

**How?**  
For the given inputs, check if the results are available from the cache storage.
If yes then return cached results.
Else execute function for the given inputs, save results into the cache storage and return it.

## References

* [Memoize in JavaScript and React](https://www.freecodecamp.org/news/memoization-in-javascript-and-react/)
