# S in SOLID Principles - SRP - Single Responsibility Principle

The Single Responsibility Principle (SRP) states that there should never be more than one reason for a class to change.  
In other words, every class should have only one responsibility.  

Seperation of Concerns is there.

Another wording for the Single Responsibility Principle is:  
Gather together the things that change for the same reasons.  
Separate those things that change for different reasons.  

Importance:  

* Maintainability: When classes have a single, well-defined responsibility, they're easier to understand and modify.
* Testability: It's easier to write unit tests for classes with a single focus.
* Flexibility: Changes to one responsibility don't affect unrelated parts of the system.

References:  

* [Wikipedia > SOLID](https://en.wikipedia.org/wiki/SOLID)
* [Wikipedia > Single Responsibility Principle](https://en.wikipedia.org/wiki/Single-responsibility_principle)

## Code Example - Without SRP

```JavaScript
// Product.ts
class Product {
    id: string;
    name: string;
    price: number;

    constructor (id: string, name: string, price: number) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
}

export {
    Product
};

// Order.ts
import { Product } from './Product.js';

class Order {
    products: Product[] = [];

    addProduct(product: Product): void {
        this.products.push(product);
    }

    getProducts(): Product[] {
        return this.products;
    }

    removeProduct(productId: string) {
        this.products = this.products.filter((product) => product.id !== productId);
    }

    calculateOrderTotal() {
        return this.products.reduce((total, product) => total + product.price, 0);
    }

    generateInvoice() {
        console.log(`
Invoice Date: ${new Date().toDateString()}
----------------------------------------
Product Name\tPrice`);

        this.products.forEach((product) => {
            console.log(`${product.name}\t\t${product.price}`);
        });

        console.log('----------------------------------------');

        console.log(`Order Total: ${this.calculateOrderTotal()}`);
    }

    processPayment() {
        console.log('Processing payment...');
        console.log('Payment processed successfully.');
        console.log('Added to accounting system.');
        console.log('Initiated shipping...');
        console.log('Email/SMS notifications are sent.');
    }
}

export {
    Order
};

// index.ts
import { Product } from "./Product.js";
import { Order } from "./Order.js";

const tShirt = new Product('1001', 'T-Shirt', 500);
const jeans = new Product('1002', 'Jeans', 1000);
const shirt = new Product('1003', 'Shirt', 700);

const order = new Order();

order.addProduct(tShirt);
order.addProduct(jeans);
order.addProduct(shirt);

console.log(`Order Total: ${order.calculateOrderTotal()}`);
console.log('\n');
order.processPayment();
console.log('\n');
order.generateInvoice();
console.log('\n');
```

Here as we can see Order class is doing multiple things:

* managing products (add, remove, list)
* calculating order total
* payment processing
* generating invoice
etc.

Later on if we need to do any changes in payment process, invoice or order total calculations then we need to change Order class.
So Order class has multiple reasons to change, which is violating SRP.

Order class has become BIG and MESSY.
Its not easy to maintain, test or understand.

We must apply SRP here to keep Order class SHORT and SIMPLE.
We can start by moving out each of the functionality from the Order class,  
and write seperate classes for each of them.

So we can have seperate classes for payment process, invoice and order total calculations.

That way each class will have a single responsibility, SRP is followed.

## Code Example - With SRP

```JavaScript

```
