# S in SOLID Principles - SRP - Single Responsibility Principle

The Single Responsibility Principle (SRP) states that there should never be more than one reason for a class to change.  
In other words, every class should have only one responsibility.  

Seperation of Concerns is there.

Another wording for the Single Responsibility Principle is:  
Gather together the things that change for the same reasons.  
Separate those things that change for different reasons.  

Importance:  

* Maintainability: When classes have a single, well-defined responsibility, they're easier to understand and modify.
* Testability: It's easier to write unit tests for classes with a single focus.
* Flexibility: Changes to one responsibility don't affect unrelated parts of the system.

References:  

* [Wikipedia > SOLID](https://en.wikipedia.org/wiki/SOLID)
* [Wikipedia > Single Responsibility Principle](https://en.wikipedia.org/wiki/Single-responsibility_principle)

## Code Example - Without SRP

```TypeScript
// Product.ts
class Product {
    id: string;
    name: string;
    price: number;

    constructor (id: string, name: string, price: number) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
}

export {
    Product
};

// Order.ts
import { Product } from './Product.js';

class Order {
    products: Product[] = [];

    addProduct(product: Product): void {
        this.products.push(product);
    }

    getProducts(): Product[] {
        return this.products;
    }

    removeProduct(productId: string) {
        this.products = this.products.filter((product) => product.id !== productId);
    }

    calculateOrderTotal() {
        return this.products.reduce((total, product) => total + product.price, 0);
    }

    generateInvoice() {
        console.log(`
Invoice Date: ${new Date().toDateString()}
----------------------------------------
Product Name\tPrice`);

        this.products.forEach((product) => {
            console.log(`${product.name}\t\t${product.price}`);
        });

        console.log('----------------------------------------');

        console.log(`Order Total: ${this.calculateOrderTotal()}`);
    }

    processPayment() {
        console.log('Processing payment...');
        console.log('Payment processed successfully.');
        console.log('Added to accounting system.');
        console.log('Initiated shipping...');
        console.log('Email/SMS notifications are sent.');
    }
}

export {
    Order
};

// index.ts
import { Product } from "./Product.js";
import { Order } from "./Order.js";

const tShirt = new Product('1001', 'T-Shirt', 500);
const jeans = new Product('1002', 'Jeans', 1000);
const shirt = new Product('1003', 'Shirt', 700);

const order = new Order();

order.addProduct(tShirt);
order.addProduct(jeans);
order.addProduct(shirt);

console.log(`Order Total: ${order.calculateOrderTotal()}`);
console.log('\n');
order.processPayment();
console.log('\n');
order.generateInvoice();
console.log('\n');
```

Here as we can see Order class is doing multiple things:

* managing products (add, remove, list)
* calculating order total
* payment processing
* generating invoice
etc.

Later on if we need to do any changes in payment process, invoice or order total calculations then we need to change Order class.
So Order class has multiple reasons to change, which is violating SRP.

**Problems:**  

* Order class => BIG and MESSY
* Not easy to maintain
* Not easy to read/understand, its long
* Not easy to test, need to write and verify multiple test cases
* Handling multiple things, so it has multiple reasons to change
* No seperation of concerns, things are tightly coupled

**Solution:**  

* Apply SRP here to make Order class SHORT and SIMPLE.
* Identify which things can be moved out from the Order class into their own seperate classes, and write seperate classes for each of them. Do this refactoring one step at a time.

After applying SRP, we can have seperate classes for payment process, invoice and order total calculations.
That way each class will have a single responsibility, SRP is followed.

## Code Example - With SRP

```TypeScript
// Product.ts
class Product {
    id: string;
    name: string;
    price: number;

    constructor (id: string, name: string, price: number) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
}

export {
    Product
};

// Order.ts
import { Product } from './Product.js';

class Order {
    products: Product[] = [];

    addProduct(product: Product): void {
        this.products.push(product);
    }

    removeProduct(productId: string) {
        this.products = this.products.filter((product) => product.id !== productId);
    }

    getProducts(): Product[] {
        return this.products;
    }
}

export {
    Order
};

// OrderPricing.ts
import type { Order } from "./Order.js";

class OrderPricing {
    order: Order;

    constructor(order: Order) {
        this.order = order;
    }

    calculateOrderTotal() {
        return this.order.products.reduce((total, product) => total + product.price, 0);
    }
}

export {
    OrderPricing
};

// OrderInvoice.ts
import type { Order } from "./Order.js";
import type { OrderPricing } from "./OrderPricing.js";

class OrderInvoice {
    order: Order;
    orderPricing: OrderPricing;

    constructor(order: Order, orderPricing: OrderPricing) {
        this.order = order;
        this.orderPricing = orderPricing;
    }

    generateInvoice() {
        console.log(`
Invoice Date: ${new Date().toDateString()}
----------------------------------------
Product Name\tPrice`);

        this.order.products.forEach((product) => {
            console.log(`${product.name}\t\t${product.price}`);
        });

        console.log('----------------------------------------');

        console.log(`Order Total: ${this.orderPricing.calculateOrderTotal()}`);
    }
}

export {
    OrderInvoice
};

// OrderPayment.ts
import type { Order } from "./Order.js";

class OrderPayment {
    order: Order;

    constructor(order: Order) {
        this.order = order;
    }

    processPayment() {
        console.log('Processing payment...');
        console.log('Payment processed successfully.');
        console.log('Added to accounting system.');
        console.log('Initiated shipping...');
        console.log('Email/SMS notifications are sent.');
    }
}

export {
    OrderPayment
};

// index.ts
import { Product } from "./Product.js";
import { Order } from "./Order.js";
import { OrderPricing } from "./OrderPricing.js";
import { OrderInvoice } from "./OrderInvoice.js";
import { OrderPayment } from "./OrderPayment.js";

const tShirt = new Product('1001', 'T-Shirt', 500);
const jeans = new Product('1002', 'Jeans', 1000);
const shirt = new Product('1003', 'Shirt', 700);

const order = new Order();

order.addProduct(tShirt);
order.addProduct(jeans);
order.addProduct(shirt);

const orderPricing = new OrderPricing(order);
const orderInvoice = new OrderInvoice(order, orderPricing);
const orderPayment = new OrderPayment(order);

console.log(`Order Total: ${orderPricing.calculateOrderTotal()}`);
console.log('\n');
orderPayment.processPayment();
console.log('\n');
orderInvoice.generateInvoice();
console.log('\n');
```

Here after SRP is followed, we now have multiple classes, each of them have a single responsibility.

**Benefits:**  

* Multiple classes, each class => SMALL and CLEAN
* Easy to maintain
* Easy to read/understand, its short
* Easy to test, since classes are now SMALL and CLEAN, we need to write fewer test cases
* Each class handles one thing and has single reason to change
* Seperation of concerns is there, things are now loosely coupled

---

**Key Takeaways**  

While writing a class:  

* KISS (Keep It Short & Simple), SMALL & CLEAN
* Single responsibility
* Seperation of concerns

---

## SRP Checklist

[] A class has one clear responsibility, focused on doing one thing.  
[] A class has only one reason to change.  
[] Test cases for this class focus on one type of behavior.  
