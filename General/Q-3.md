# L in SOLID Principles - LSP - Liskov Substitution Principle

The Liskov Substitution Principle (LSP) states that functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.

An object (such as a class) may be replaced by a sub-object (such as a class that extends the first class) without breaking the program. It is a semantic rather than merely syntactic relation, because it intends to guarantee semantic interoperability of types in a hierarchy, object types in particular.

Replacing a super-class object with a sub-class object won't break the program.

In other words, child should be able to do everything that the parent can do without fail.

Importance:  

* Polymorphism: Enables the use of polymorphic behavior, making code more flexible and reusable.
* Reliability: Ensures that subclasses adhere to the contract defined by the superclass.
* Predictability: Guarantees that replacing a superclass object with a subclass object won't break the program.

References:  

* [Wikipedia > SOLID](https://en.wikipedia.org/wiki/SOLID)
* [Wikipedia > Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
* [Wikipedia > Design by Contract](https://en.wikipedia.org/wiki/Design_by_contract)

## Code Example - Without LSP

```TypeScript
// Bird.ts
class Bird {
    fly(): void {
        console.log('A bird can fly...');
    }

    makeSound(): void {
        console.log('A bird can make a sound...');
    }
}

export {
    Bird
};

// Sparrow.ts
import { Bird } from "./Bird.js";

class Sparrow extends Bird {
    fly(): void {
        console.log('A sparrow can fly...');
    }

    makeSound(): void {
        console.log('A sparrow can make a sound...');
    }
}

export {
    Sparrow
};

// Eagle.ts
import { Bird } from "./Bird.js";

class Eagle extends Bird {
    fly(): void {
        console.log('An eagle can fly...');
    }

    makeSound(): void {
        console.log('An eagle can make a sound...');
    }
}

export {
    Eagle
};

// Penguin.ts
import { Bird } from "./Bird.js";

class Penguin extends Bird {
    fly(): void {
        throw Error('A penguin cannot fly');
    }

    makeSound(): void {
        console.log('A penguin can make a sound...');
    }
}

export {
    Penguin
};

// index.ts
import { Bird } from "./Birds/Bird.js";
import { Eagle } from "./Birds/Eagle.js";
import { Penguin } from "./Birds/Penguin.js";
import { Sparrow } from "./Birds/Sparrow.js";

function makeBirdFly(bird: Bird): void {
    bird.fly();
}

makeBirdFly(new Bird());
makeBirdFly(new Sparrow());
makeBirdFly(new Eagle());
makeBirdFly(new Penguin()); // <-- this will break the program as it throws an error - A penguin cannot fly
```

**Problems:**  

Here there is no problem with Bird, Sparrow and Eagle, but Penguin.
Penguin cannot fly and it throws an error.

We can replace Bird object with Sparrow or Eagle object without breaking anything.
But when we replace Bird object with Penguin it fails.

Problem is - Penguin extends Bird but it does not have all the abilities that the Bird has.

**Solution:**  

While inheriting we need to make sure that - a child class must be able to do everything a parent class can do.
If not then we should not inherit/extend from that parent class.

We need to correct class hierarchy here.
Penguin cannot extend Bird since it cannot fly.
We will add one more base class on top of Bird, lets say BaseBird.
Check the code example for more details.

## Code Example - With LSP

```TypeScript
// BaseBird.ts
class BaseBird {
    makeSound(): void {
        console.log('A base bird can make a sound...');
    }
}

export {
    BaseBird
};

// Bird.ts
import { BaseBird } from "./BaseBird.js";

class Bird extends BaseBird {
    fly(): void {
        console.log('A bird can fly...');
    }

    makeSound(): void {
        console.log('A bird can make a sound...');
    }
}

export {
    Bird
};

// Sparrow.ts
import { Bird } from "./Bird.js";

class Sparrow extends Bird {
    fly(): void {
        console.log('A sparrow can fly...');
    }

    makeSound(): void {
        console.log('A sparrow can make a sound...');
    }
}

export {
    Sparrow
};

// Eagle.ts
import { Bird } from "./Bird.js";

class Eagle extends Bird {
    fly(): void {
        console.log('An eagle can fly...');
    }

    makeSound(): void {
        console.log('An eagle can make a sound...');
    }
}

export {
    Eagle
};

// Penguin.ts
import { BaseBird } from "./BaseBird.js";

class Penguin extends BaseBird {
    makeSound(): void {
        console.log('A penguin can make a sound...');
    }
}

export {
    Penguin
};

// index.ts
import { Bird } from "./Birds/Bird.js";
import { Eagle } from "./Birds/Eagle.js";
import { Penguin } from "./Birds/Penguin.js";
import { Sparrow } from "./Birds/Sparrow.js";

function makeBirdFly(bird: Bird): void {
    bird.fly();
}

makeBirdFly(new Bird());
makeBirdFly(new Sparrow());
makeBirdFly(new Eagle());
makeBirdFly(new Penguin()); // <-- Gives an error - 'Penguin' is not assignable to parameter of type 'Bird'
```

**Benefits:**  

* Helps us to create correct class hierarchy/inheritance.
* Polymorphic behavior can be achieved.
* A parent class object can be replaced with its child class object without breaking anything.

One more example with LSP:  

In the following example, class hierarchy is correctly defined.
Since Customer can't access internal system we defined a common base class "BaseUser" for all types of users.
So Customer extends from BaseUser and system users like Admin, SuperAdmin, CustomerSupport and TechSupport  
extends from SystemUser.  

Class hierarchy is as follows:  
BaseUser
|
|-- Customer
|
|-- SystemUser
    |
    |-- Admin
    |-- SuperAdmin
    |-- CustomerSupport
    |-- TechSupport

```TypeScript
class BaseUser {
    activate(): void {
        // Activate user account
    }

    block(): void {
        // Block user account
    }
}

class SystemUser {
    getRole() {
        // Get system user role
    }

    getPermissions() {
        // Get system user permissions
    }
}

class Customer extends BaseUser {
    //
}

class Admin extends SystemUser {
    //
}

class SuperAdmin extends SystemUser {
    //
}

class CustomerSupport extends SystemUser {
    //
}

class TechSupport extends SystemUser {
    //
}
```
