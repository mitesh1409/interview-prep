# L in SOLID Principles - LSP - Liskov Substitution Principle

The Liskov Substitution Principle (LSP) states that functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.

An object (such as a class) may be replaced by a sub-object (such as a class that extends the first class) without breaking the program. It is a semantic rather than merely syntactic relation, because it intends to guarantee semantic interoperability of types in a hierarchy, object types in particular.

Replacing a super-class object with a sub-class object won't break the program.

In other words, child should be able to do everything that the parent can do without fail.

Importance:  

* Polymorphism: Enables the use of polymorphic behavior, making code more flexible and reusable.
* Reliability: Ensures that subclasses adhere to the contract defined by the superclass.
* Predictability: Guarantees that replacing a superclass object with a subclass object won't break the program.

References:  

* [Wikipedia > SOLID](https://en.wikipedia.org/wiki/SOLID)
* [Wikipedia > Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
* [Wikipedia > Design by Contract](https://en.wikipedia.org/wiki/Design_by_contract)

## Code Example - Without LSP

```TypeScript
// Bird.ts
class Bird {
    fly(): void {
        console.log('A bird can fly...');
    }

    makeSound(): void {
        console.log('A bird can make a sound...');
    }
}

export {
    Bird
};

// Sparrow.ts
import { Bird } from "./Bird.js";

class Sparrow extends Bird {
    fly(): void {
        console.log('A sparrow can fly...');
    }

    makeSound(): void {
        console.log('A sparrow can make a sound...');
    }
}

export {
    Sparrow
};

// Eagle.ts
import { Bird } from "./Bird.js";

class Eagle extends Bird {
    fly(): void {
        console.log('An eagle can fly...');
    }

    makeSound(): void {
        console.log('An eagle can make a sound...');
    }
}

export {
    Eagle
};

// Penguin.ts
import { Bird } from "./Bird.js";

class Penguin extends Bird {
    fly(): void {
        throw Error('A penguin cannot fly');
    }

    makeSound(): void {
        console.log('A penguin can make a sound...');
    }
}

export {
    Penguin
};

// index.ts
import { Bird } from "./Birds/Bird.js";
import { Eagle } from "./Birds/Eagle.js";
import { Penguin } from "./Birds/Penguin.js";
import { Sparrow } from "./Birds/Sparrow.js";

function makeBirdFly(bird: Bird): void {
    bird.fly();
}

makeBirdFly(new Sparrow());
makeBirdFly(new Eagle());
makeBirdFly(new Penguin()); // <-- this will break the program as it throws an error - A penguin cannot fly
```

**Problems:**  

**Solution:**  


## Code Example - With LSP

```TypeScript

```

**Benefits:**  
