# I in SOLID Principles - ISP - Interface Segregation Principle

The interface segregation principle (ISP) states that clients should not be forced to depend upon interfaces that they do not use.

In the field of software engineering, the interface segregation principle (ISP) states that no code should be forced to depend on methods it does not use. ISP splits interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. Such shrunken interfaces are also called role interfaces. ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy.

ISP is one of the five SOLID principles of object-oriented design, similar to the "High Cohesion Principle" of GRASP. Beyond object-oriented design, ISP is also a key principle in the design of distributed systems in general and one of the six IDEALS principles for microservice design.

Importance:  

* Decoupling: Reduces dependencies between classes, making the code more modular and maintainable.
* Flexibility: Allows for more targeted implementations of interfaces.
* Avoids unnecessary dependencies: Clients don't have to depend on methods they don't use.

This is like applying SRP to interfaces.

**Segregation meaning?**  
Segregation is the practice of separating people into different groups based on factors like race, religion, or sex, often leading to different treatment and opportunities. This can be enforced by law or social custom and occur in various parts of society, such as in schools, housing, and public facilities.

References:  

* [Wikipedia > SOLID](https://en.wikipedia.org/wiki/SOLID)
* [Wikipedia > Interface Segregation Principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)

## Code Example - Without ISP

```TypeScript
// IDocumentManager.ts
interface IDocumentManager {
    createDocument(): void;
    getDocumentInfo(): void;
    saveDocument(): void;
    deleteDocument(): void;
    openDocument(): void;
    closeDocument(): void;
    scanDocument(): void;
    copyDocument(): void;
    printDocument(): void;
}

export type {
    IDocumentManager
};

// BasicCodeEditor.ts
import type { IDocumentManager } from "./IDocumentManager.js";

class BasicCodeEditor implements IDocumentManager {
    createDocument(): void {
        console.log('Create document');
    }

    getDocumentInfo(): void {
        console.log('Get document info');
    }

    saveDocument(): void {
        console.log('Save document');
    }

    deleteDocument(): void {
        console.log('Delete document');
    }

    openDocument(): void {
        console.log('Open document');
    }

    closeDocument(): void {
        console.log('Close document');
    }

    scanDocument(): void {
        throw Error('Scan document feature not available');
    }

    copyDocument(): void {
        throw Error('Copy document feature not available');
    }

    printDocument(): void {
        throw Error('Print document feature not available');
    }
}

export {
    BasicCodeEditor
};

// AdvanceCodeEditor.ts
import type { IDocumentManager } from "./IDocumentManager.js";

class AdvanceCodeEditor implements IDocumentManager {
    createDocument(): void {
        console.log('Create document');
    }

    getDocumentInfo(): void {
        console.log('Get document info');
    }

    saveDocument(): void {
        console.log('Save document');
    }

    deleteDocument(): void {
        console.log('Delete document');
    }

    openDocument(): void {
        console.log('Open document');
    }

    closeDocument(): void {
        console.log('Close document');
    }

    scanDocument(): void {
        console.log('Scan document');
    }

    copyDocument(): void {
        console.log('Copy document');
    }

    printDocument(): void {
        console.log('Print document');
    }
}

export {
    AdvanceCodeEditor
};
```

**Problems:**  

There are following problems:  

* Interface IDocumentManager is doing multiple things, we should think about spliting it into multiple interfaces.
* Class BasicCodeEditor does not provide scan, copy and print features but still it has to implement those methods.
* Violation of ISP.

**Solution:**  

Segregate IDocumentManager interface into multiple interfaces to make it simpler.  
That way we will try to apply ISP.  


## Code Example - With ISP

```TypeScript
// IDocumentManager.ts
// A set of document manager interfaces.

// Split the large document manager interface into smaller, focused interfaces
interface ICreatable {
    createDocument(): void;
}

interface IReadable {
    getDocumentInfo(): void;
    openDocument(): void;
    closeDocument(): void;
}

interface IWritable {
    saveDocument(): void;
}

interface IDeletable {
    deleteDocument(): void;
}

interface IScannable {
    scanDocument(): void;
}

interface ICopiable {
    copyDocument(): void;
}

interface IPrintable {
    printDocument(): void;
}

// Convenience composite interface for implementations that need all capabilities
interface IDocumentManager extends
    ICreatable,
    IReadable,
    IWritable,
    IDeletable,
    IScannable,
    ICopiable,
    IPrintable {}

export type {
    IDocumentManager,
    ICreatable,
    IReadable,
    IWritable,
    IDeletable,
    IScannable,
    ICopiable,
    IPrintable
};

// BasicCodeEditor.ts
import type { ICreatable, IReadable, IWritable, IDeletable } from "./IDocumentManager.js";

class BasicCodeEditor implements IDocumentManager {
    createDocument(): void {
        console.log('Create document');
    }

    getDocumentInfo(): void {
        console.log('Get document info');
    }

    saveDocument(): void {
        console.log('Save document');
    }

    deleteDocument(): void {
        console.log('Delete document');
    }

    openDocument(): void {
        console.log('Open document');
    }

    closeDocument(): void {
        console.log('Close document');
    }
}

export {
    BasicCodeEditor
};

// AdvanceCodeEditor.ts
import type { IDocumentManager } from "./IDocumentManager.js";

class AdvanceCodeEditor implements IDocumentManager {
    createDocument(): void {
        console.log('Create document');
    }

    getDocumentInfo(): void {
        console.log('Get document info');
    }

    saveDocument(): void {
        console.log('Save document');
    }

    deleteDocument(): void {
        console.log('Delete document');
    }

    openDocument(): void {
        console.log('Open document');
    }

    closeDocument(): void {
        console.log('Close document');
    }

    scanDocument(): void {
        console.log('Scan document');
    }

    copyDocument(): void {
        console.log('Copy document');
    }

    printDocument(): void {
        console.log('Print document');
    }
}

export {
    AdvanceCodeEditor
};
```

**Benefits:**  

* SMALL and CLEAN interfaces.
* Classes can implement required interfaces.

---

**Key Takeaways**  

* SMALL and CLEAN interfaces.
* It is like applying SRP to interfaces.

**ISP (Interface Segregation Principle):**  
Focus: interfaces.
Rule: clients should only depend on the methods they actually use.
Effect: break large “fat” interfaces into many small, cohesive ones so implementers/consumers aren’t forced to implement or depend on unused methods.

**SRP (Single Responsibility Principle):**  
Focus: classes/modules.
Rule: a class/module should have only one reason to change (one responsibility).
Effect: keeps implementation units small and focused.
