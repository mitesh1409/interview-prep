# D in SOLID Principles - DIP - Dependency Inversion Principle

The Dependency Inversion Principle (DIP) states to depend upon abstractions, not concretes.

The principle states:  

High-level modules should not import anything from low-level modules. Both should depend on abstractions (e.g., interfaces).  
Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.  
By dictating that both high-level and low-level objects must depend on the same abstraction, this design principle inverts the way some people may think about object-oriented programming.

Importance:  

* Loose coupling: Reduces dependencies between modules, making the code more flexible and easier to test.
* Flexibility: Enables changes to implementations without affecting clients.
* Maintainability: Makes code easier to understand and modify.

**Key Terms**  

* **High-level Module:** Contains important business logic or policy. (e.g., A class that handles ordering food.)

* **Low-level Module:** Contains implementation details used to execute a task. (e.g., A class that specifically connects to a SQL database or a specific payment API.)

* **Abstraction (Interface/Abstract Class):** A contract or blueprint that defines the methods but not the implementation.

In essence, DIP "inverts" the typical top-down dependency flow. Instead of the high-level logic being tied to specific low-level implementations, you insert an interface in the middle. The high-level module depends on the interface, and the low-level implementation also implements that interface.

This reduces coupling and makes the code:  

* **Easier to test:** You can swap out the real low-level module with a "mock" implementation for testing.

* **More flexible:** You can change the underlying technology (e.g., switch from MySQL to MongoDB) without altering the core business logic.

References:  

* [Wikipedia > SOLID](https://en.wikipedia.org/wiki/SOLID)
* [Wikipedia > Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)

## Code Example - Without DIP

Example: Logging System  

```TypeScript
// Low-level Module (Specific Implementation)
class ConsoleLogger {
    log(message: string): void {
        console.log(`[LOG]: ${message}`);
    }
}

// High-level Module
class OrderProcessor {
    // Direct Dependency on Concrete Class!
    constructor(private logger: ConsoleLogger) {
        //
    }

    process(orderId: number): void {
        // Core business logic
        // ...
        this.logger.log(`Order ${orderId} processed successfully.`); 
    }
}

const orderProcessor = new OrderProcessor(new ConsoleLogger());
orderProcessor.process(1001);
```

**Problems:**  

* High level modules and low level modules are tightly coupled.
* Whenever there is a change in low level module, we need to change high level module as well.

**Solution:**  

Apply DIP.

## Code Example - With DIP

Example: Logging System  

```TypeScript
// Abstraction (Interface)
interface ILogger {
    log(message: string): void;
}

// Low-level Module 1 (Concrete Implementation)
class ConsoleLogger implements ILogger {
    log(message: string): void {
        console.log(`[LOG - Console]: ${message}`);
    }
}

// Low-level Module 2 (Concrete Implementation) - Easy to swap in!
class FileLogger implements ILogger {
    log(message: string): void {
        // In a real app, this would write to a file
        console.warn(`[LOG - File]: Writing to file: ${message}`);
    }
}

// High-level Module (Depends on Abstraction - ILogger)
class OrderProcessor {
    // Dependency is injected through the constructor!
    private logger: ILogger; 

    constructor(logger: ILogger) {
        this.logger = logger;
    }

    process(orderId: number): void {
        // Core business logic
        // ...
        this.logger.log(`Order ${orderId} finalized.`); 
    }
}

// Usage: The client decides which concrete logger to use
const consoleProcessor = new OrderProcessor(new ConsoleLogger());
consoleProcessor.process(101); // Uses ConsoleLogger

const fileProcessor = new OrderProcessor(new FileLogger());
fileProcessor.process(102); // Uses FileLogger, and we didn't touch OrderProcessor!
```

Example: Data Persistence  

```TypeScript
// Abstraction (Interface)
interface IUserRepository {
    saveUser(user: { id: number, name: string }): void;
    getUser(id: number): { id: number, name: string } | null;
}

// Low-level Module 1 (Concrete Implementation)
class MongoDBRepository implements IUserRepository {
    saveUser(user: { id: number, name: string }): void {
        console.log(`[MongoDB]: Saving user ${user.name} to MongoDB collection.`);
    }
    getUser(id: number): { id: number, name: string } | null {
        console.log(`[MongoDB]: Fetching user ${id}.`);
        return { id: id, name: "Mongo User" };
    }
}

// High-level Module (Depends on Abstraction - IUserRepository)
class UserService {
    private repository: IUserRepository;

    // Dependency Injection via constructor
    constructor(repository: IUserRepository) {
        this.repository = repository;
    }

    createUser(id: number, name: string): void {
        // Business logic to create user after validating data.
        // ...
        this.repository.saveUser({ id, name });
    }
}

// Using the High-level module with a low-level implementation
const mongoRepo = new MongoDBRepository();
const userService = new UserService(mongoRepo); // Injects the MongoDB dependency

userService.createUser(5, "Alice");
```

**Benefits:**  

* Loose coupling: Reduces dependencies between modules, making the code more flexible and easier to test, easy to mock.
* Flexibility: Enables changes to implementations without affecting clients.
* Maintainability: Makes code easier to understand and modify.

---

**Key Takeaways**  

A high module may depend on one or more lower level modules.  

**Without DIP**  
A high level module depends on concrete low level modules,  
means it directly uses concrete low level modules.  
So whenever there is change in the low level module,  
we need to change high level module as well.  
Here high level modules and low level modules are tightly coupled.  
Dependency flow is Top-Down.  

**With DIP**  
Instead of directly using concrete modules,  
a high level module uses concrete modules via an interface.  
Low level module then implements this interface.  
Even if there is a change in the low level module,  
we don't need to change anything in the high level module.  
Here high level modules and low level modules are loosely coupled.  
Dependency flow is Down-Top (inverted).
