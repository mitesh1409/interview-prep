# O in SOLID Principles - OCP - Open-Closed Principle

The Openâ€“Closed Principle (OCP) states that software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification; that is, such an entity can allow its behaviour to be extended without modifying its source code.

Importance:  

* Extensibility: New features can be added without modifying existing code.
* Stability: Reduces the risk of introducing bugs when making changes.
* Flexibility: Adapts to changing requirements more easily.

References:  

* [Wikipedia > SOLID](https://en.wikipedia.org/wiki/SOLID)
* [Wikipedia > Single Responsibility Principle](https://en.wikipedia.org/wiki/Single-responsibility_principle)

## Code Example - Without OCP

```TypeScript
// PaymentProcessor.ts
class PaymentProcessor {
    amount: number;
    paymentMethod: string;

    constructor(amount: number, paymentMethod: string) {
        this.amount = amount;
        this.paymentMethod = paymentMethod;
    }

    processPayment() {
        try {
            switch (this.paymentMethod) {
                case 'credit-card':
                    console.log('Process payment using Credit Card...');
                    break;
                case 'paypal':
                    console.log('Process payment using Paypal...');
                    break;
                case 'stripe':
                    console.log('Process payment using Stripe...');
                    break;
                default:
                    throw new Error('Invalid payment method');
            }
        } catch (error) {
            console.error('Failed to process payment');
            console.error(error);
        }

        return;
    }
}

export {
    PaymentProcessor
};

// index.ts
import { PaymentProcessor } from "./PaymentProcessor.js";

const paymentAmount = 500;
const paymentMethod = 'credit-card';

const paymentProcessor = new PaymentProcessor(paymentAmount, paymentMethod);

paymentProcessor.processPayment();
```

Here PaymentProcessor class supports 3 payment methods: Credit Card, Paypal & Stripe.  

The class is written in a way that if tomorrow we need to support couple of more payment methods like Debit Card & UPI then we need to modify its code. It is not open for extension.  
Currently PaymentProcessor class is open for modification and closed for extension.  
This violates OCP.

**Problems:**  

* To implement new features, we need to modify the same class
* We need to rewrite/revisit all of its test cases
* Takes longer to implement and roll out new features
* Gradually it starts to become BIG and MESSY as we do more modifications into it

**Solution:**  

Apply OCP.  
A class should be written in a way that it is open for extension and closed for modifications.  

## Code Example - With OCP

```TypeScript
// IPaymentProcessor.ts
interface IPaymentProcessor {
    processPayment(amount: number): void;
}

export type {
    IPaymentProcessor
};

// CreditCardPaymentProcessor.ts
import type { IPaymentProcessor } from "./IPaymentProcessor.js";

class CreditCardPaymentProcessor implements IPaymentProcessor {
    processPayment(amount: number): void {
        console.log(`Process payment of ${amount} using Credit Card...`);
    }
}

export {
    CreditCardPaymentProcessor
};

// DebitCardPaymentProcessor.ts
import type { IPaymentProcessor } from "./IPaymentProcessor.js";

class DebitCardPaymentProcessor implements IPaymentProcessor {
    processPayment(amount: number): void {
        console.log(`Process payment of ${amount} using Debit Card...`);
    }
}

export {
    DebitCardPaymentProcessor
};

// PaypalPaymentProcessor.ts
import type { IPaymentProcessor } from "./IPaymentProcessor.js";

class PaypalPaymentProcessor implements IPaymentProcessor {
    processPayment(amount: number): void {
        console.log(`Process payment of ${amount} using Paypal...`);
    }
}

export {
    PaypalPaymentProcessor
};

// StripePaymentProcessor.ts
import type { IPaymentProcessor } from "./IPaymentProcessor.js";

class StripePaymentProcessor implements IPaymentProcessor {
    processPayment(amount: number): void {
        console.log(`Process payment of ${amount} using Stripe...`);
    }
}

export {
    StripePaymentProcessor
};

// UpiPaymentProcessor.ts
import type { IPaymentProcessor } from "./IPaymentProcessor.js";

class UpiPaymentProcessor implements IPaymentProcessor {
    processPayment(amount: number): void {
        console.log(`Process payment of ${amount} using UPI...`);
    }
}

export {
    UpiPaymentProcessor
};

// PaymentProcessor.ts
import type { IPaymentProcessor } from "./IPaymentProcessor.js";

class PaymentProcessor {
    paymentProcessor: IPaymentProcessor;

    constructor(paymentProcessor: IPaymentProcessor) {
        this.paymentProcessor = paymentProcessor;
    }

    processPayment(amount: number): void {
        this.paymentProcessor.processPayment(amount);
    }
}

export {
    PaymentProcessor
};

// index.ts
import { CreditCardPaymentProcessor } from "./PaymentProcessor/CreditCardPaymentProcessor.js";
import { PaymentProcessor } from "./PaymentProcessor/PaymentProcessor.js";
import { StripePaymentProcessor } from "./PaymentProcessor/StripePaymentProcessor.js";

const amount = 500;

const creditCardPaymentProcessor = new CreditCardPaymentProcessor();
let paymentProcessor = new PaymentProcessor(creditCardPaymentProcessor);
paymentProcessor.processPayment(amount);

const stripePaymentProcessor = new StripePaymentProcessor();
paymentProcessor = new PaymentProcessor(stripePaymentProcessor);
paymentProcessor.processPayment(amount);
```

**Benefits:**  

* To implement new features, we don't need to modify any existing class, we can extend instead (by adding new classes)
* Takes less time to implement new features as we are not touching existing classes/code
* Helps us to keep classes SMALL and CLEAN
