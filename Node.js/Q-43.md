# What is clustering in Node.js and when should it be used?

## What is Clustering in Node.js and When Should It Be Used?

Clustering in Node.js is a technique that allows an application to **spawn multiple Node.js processes (workers)** to take advantage of **multi-core CPUs**. Since a single Node.js process runs on a single thread and can utilize only one CPU core, clustering enables better **CPU utilization, throughput, and fault tolerance** for server applications.

---

## How Clustering Works

By default, Node.js runs JavaScript on a single thread with an event loop. While it handles I/O efficiently, it can only use one CPU core.

The `cluster` module allows a **primary (master) process** to fork multiple **worker processes**, typically equal to the number of CPU cores. All workers:

* Run the same application code
* Share the same server port
* Handle requests independently

The operating system (or Node’s internal scheduler) distributes incoming connections across workers.

If a worker crashes, the primary process can detect this and **restart it**, improving availability.

---

## When to Use Clustering

You should use clustering in the following scenarios:

### 1. High-Traffic Applications

When your server must handle a large number of concurrent HTTP requests, clustering helps distribute the load across CPU cores, improving throughput and response time.

### 2. CPU Pressure from Many Concurrent Requests

Clustering is useful when **multiple simultaneous requests collectively cause CPU usage to spike**. Each worker runs on a separate core, preventing one busy event loop from becoming a bottleneck.

> Important: Clustering does **not** parallelize a single CPU-intensive task. For that use case, worker threads are more appropriate.

### 3. Improved Scalability on a Single Machine

Clustering allows vertical scaling by fully utilizing all CPU cores available on a single server.

### 4. Fault Tolerance

If a worker process crashes due to an unhandled error, the primary process can restart it automatically, keeping the application running.

---

## Basic Example Using the `cluster` Module

```js
const cluster = require('cluster');
const http = require('http');
const os = require('os');

const numCPUs = os.cpus().length;

if (cluster.isPrimary) {
  console.log(`Primary process ${process.pid} is running`);

  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker) => {
    console.log(`Worker ${worker.process.pid} died. Restarting...`);
    cluster.fork();
  });
} else {
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('Hello World\n');
  }).listen(8000);

  console.log(`Worker ${process.pid} started`);
}
```

---

## Best Practices for Clustering

* Keep workers **stateless**; store shared state in Redis, databases, or external caches.
* Monitor worker health and memory usage.
* Use a reverse proxy (NGINX, AWS ALB) in front for SSL termination, logging, and multi-machine scaling.
* For production, use process managers like **PM2**, which provide built-in clustering, monitoring, and zero-downtime restarts.

---

## When NOT to Use Clustering

* For **single, heavy CPU-bound computations** → use **worker threads**
* As a replacement for horizontal scaling across multiple machines
* For small, low-traffic applications where added complexity provides no benefit

---

## One-Line Interview Summary

> *Clustering in Node.js improves performance and reliability by running multiple Node.js processes across CPU cores, making it ideal for high-traffic, I/O-heavy server applications—but it does not parallelize single CPU-intensive tasks.*
