# What happens if an uncaught exception occurs? OR The purpose of using global error handlers like `process.on('uncaughtException')`

## Uncaught Exceptions in Node.js

An uncaught exception is a **synchronous error** that was thrown somewhere in your code but never caught by a `try/catch` block.

```javascript
// Example — synchronous error with no try/catch around it
const obj = null;
console.log(obj.property); // TypeError: Cannot read properties of null
```

Without any handler, Node.js will print the error stack trace and **immediately crash the process** — unlike `unhandledRejection` which had a grace period in older versions, `uncaughtException` has **always** crashed the process by default.

---

## `process.on('uncaughtException')`

```javascript
process.on('uncaughtException', (err, origin) => {
    console.error('Uncaught Exception:', err.message);
    console.error('Error origin:', origin); // 'uncaughtException' or 'unhandledRejection'
    console.error('Stack:', err.stack);

    // 1. Log to error monitoring service (Sentry, Datadog, etc.)
    // errorMonitor.capture(err);

    // 2. Gracefully shut down
    server.close(() => {
        process.exit(1); // exit with failure code
    });
});
```

The callback receives two arguments — the `err` object itself, and `origin` which tells you whether it came from a thrown exception or a rejected Promise.

---

## The Critical Warning — Don't Misuse It

This is the most important thing to understand about `uncaughtException`:

> **Node.js official docs strongly advise against using `uncaughtException` to keep the process running after an error.**

The reason is that when an uncaught exception occurs, your application is in an **unknown, potentially corrupt state**. Memory may be leaked, open connections may be in a broken state, data may be partially written. Trying to continue is dangerous.

```javascript
// ❌ BAD — swallowing the error and continuing
process.on('uncaughtException', (err) => {
    console.error('Error occurred, but continuing...', err);
    // app keeps running in a potentially broken state
});

// ✅ GOOD — log it and exit gracefully
process.on('uncaughtException', (err) => {
    console.error('Fatal error, shutting down:', err);
    server.close(() => process.exit(1));
});
```

> The correct mental model is — use this handler to **log and die gracefully**, not to **survive**.

---

## Graceful Shutdown vs Abrupt Crash

Without the handler, Node crashes **abruptly** — in-flight requests are dropped, files may be partially written, DB connections are not released.

With the handler, you get a chance to:

- Finish or reject in-flight HTTP requests
- Close database connections cleanly
- Flush logs to disk or remote service
- Exit with a proper error code so your process manager knows it failed

---

## The Role of a Process Manager

Since `uncaughtException` should always end in `process.exit()`, the question becomes — *who restarts your app?* That's the job of a **process manager**:

```bash
# PM2 — most popular in Node.js ecosystem
pm2 start app.js

# PM2 will automatically restart the app if it crashes
# You can also configure max restarts, restart delay, etc.
```

Other options include **Docker restart policies**, **systemd**, or **Kubernetes** — all of which can detect a crashed process and restart it. So the pattern in production is:

```
uncaughtException fires → log error → exit(1) → process manager restarts app
```

---

## Full Picture — Both Handlers Together

```javascript
// Last resort safety nets — always set both up together
process.on('uncaughtException', (err, origin) => {
    console.error('Uncaught Exception:', err);
    server.close(() => process.exit(1));
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    server.close(() => process.exit(1));
});
```

| | `uncaughtException` | `unhandledRejection` |
|---|---|---|
| Triggered by | Synchronous thrown errors | Rejected Promises with no `.catch()` |
| Default behaviour | Always crashes | Crashes in Node v15+ |
| Safe to continue after? | No | No |
| Use as | Graceful shutdown + logging | Graceful shutdown + logging |

Both are safety nets. Neither replaces proper `try/catch` and `.catch()` handling throughout your code.
