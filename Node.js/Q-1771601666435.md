# What happens if an unhandled promise rejection occurs? OR The purpose of using global error handlers like process.on('unhandledRejection')

```javascript
process.on('unhandledRejection', (reason, promise) => {
    console.log('Unhandled Rejection at:', promise, 'reason:', reason);
    // Application specific logging, throwing an error, or other logic here
});
```

This Global event listener will catch any unhandled promise rejections in your Node.js application.  
When a promise is rejected and there is no `.catch()` handler to handle the rejection,  
the `unhandledRejection` event is emitted on the `process` object.

---

## What Actually Happens Step by Step

When a Promise is rejected without a `.catch()` handler:  

1. Node.js detects the unhandled rejection at the end of the current **microtask queue** processing
2. It emits the `unhandledRejection` event on the `process` object
3. Depending on the Node.js version, it either warns or **crashes the process**

---

## The Version Behaviour Change — Important!

This is a critical detail many people miss:  

| Node.js Version | Default Behaviour |
|---|---|
| Before v15 | Prints a deprecation warning, process **continues** |
| **v15 and above** | Process **exits with code 1** (crashes) by default |

So in modern Node.js, an unhandled rejection is treated like an uncaught exception and  
will **kill your application** unless you handle it.

---

## "unhandledRejection" Event Listener

```javascript
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise);
    console.error('Reason:', reason);

    // 1. Log to an error monitoring service (e.g. Sentry, Datadog)
    // errorMonitor.capture(reason);

    // 2. Gracefully shut down instead of abrupt crash
    // Give server time to finish existing requests
    server.close(() => {
        process.exit(1); // exit with failure code
    });
});
```

---

## Its Counterpart — `uncaughtException`

While you're here, worth knowing about its sibling for synchronous errors:  

```javascript
// Catches synchronous errors that were never caught
process.on('uncaughtException', (err) => {
    console.error('Uncaught Exception:', err);
    process.exit(1); // always exit after this — process may be in unstable state
});
```

`unhandledRejection` is for async/Promise errors,  
`uncaughtException` is for synchronous errors.  
In production apps you'd typically set up both.

---

## The `--unhandled-rejections` Flag

Node.js also gives you a CLI flag to control this behaviour explicitly:

```bash
node --unhandled-rejections=strict app.js   # always crash (recommended)
node --unhandled-rejections=warn  app.js    # only warn, don't crash
node --unhandled-rejections=none  app.js    # silence completely (not recommended)
```

---

## Best Practice Summary

The `process.on('unhandledRejection')` listener is meant to be a **safety net**, not a substitute for proper error handling. The right order of preference is:

1. Always attach `.catch()` to every Promise chain, or wrap `await` calls in `try/catch`
2. Use the global listener as a last-resort safety net to log and gracefully shut down
3. Never use it to silently swallow errors and let the app continue as if nothing happened — the app may already be in an inconsistent state by that point
