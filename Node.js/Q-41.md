# What are worker threads in Node.js, and when would you use them?

## What are Worker Threads in Node.js?

Worker threads in Node.js allow JavaScript code to run in **multiple OS-level threads** within the **same process**, enabling **true parallel execution** of JavaScript for **CPU-intensive tasks**.

By default, Node.js runs JavaScript on a **single main thread**, using an **event loop** to handle asynchronous I/O. While this model is highly efficient for I/O-bound workloads, **CPU-bound operations can block the event loop**, degrading application responsiveness.

Worker threads solve this by offloading CPU-heavy tasks to separate threads, keeping the main event loop free to handle incoming requests.

---

## When Should You Use Worker Threads?

You should use worker threads when:

1. **CPU-Intensive Tasks**
   Examples include:

   * Cryptography
   * Image / video processing
   * Data compression
   * Large mathematical computations
     These tasks would otherwise block the event loop.

2. **True Parallel Computation**
   Worker threads run on **separate CPU cores**, unlike async I/O, which is non-blocking but not parallel.

3. **Isolating Heavy Workloads**
   Each worker has its own:

   * Event loop
   * Call stack
   * Heap
     This prevents heavy computation from impacting request handling.

---

## When NOT to Use Worker Threads (Important Interview Point)

* ❌ **I/O-bound tasks** (database calls, HTTP requests, file reads)
  Node.js async I/O already handles these efficiently.
* ❌ **Short-lived or trivial computations**
  Worker creation has overhead.
* ❌ As a replacement for clustering HTTP servers
  Use `cluster` for scaling across processes, not worker threads.

---

## Code Example

To create a worker thread in Node.js, you can use the `worker_threads` module.  
Here's a simple example:  

```javascript
const { Worker, isMainThread, parentPort } = require('worker_threads');
if (isMainThread) {
  // This code is executed in the main thread
  const worker = new Worker(__filename);
  worker.on('message', (result) => {
    console.log(`Result from worker: ${result}`);
  });
  worker.on('error', (error) => {
    console.error(`Worker error: ${error}`);
  });
  worker.on('exit', (code) => {
    if (code !== 0)
      console.error(`Worker stopped with exit code ${code}`);
  });
} else {
  // This code is executed in the worker thread
  let sum = 0;
  for (let i = 0; i < 1e9; i++) {
    sum += i;
  }
  parentPort.postMessage(sum);
}
```

In this example, the main thread creates a worker thread that performs a CPU-intensive task (calculating the sum of numbers from 0 to 1 billion) without blocking the main event loop. The result is sent back to the main thread using `parentPort.postMessage()`.

**Line-by-Line Explanation of the Code**  

```js
const { Worker, isMainThread, parentPort } = require('worker_threads');
```

* Imports APIs from the `worker_threads` module:

  * `Worker`: Used to create a new worker thread
  * `isMainThread`: Boolean indicating whether the code is running on the main thread
  * `parentPort`: Communication channel between worker and parent

---

```js
if (isMainThread) {
```

* Checks whether the current execution context is the **main thread**
* This same file runs in **two modes**:

  * Main thread
  * Worker thread

---

```js
  const worker = new Worker(__filename);
```

* Creates a new worker thread
* `__filename` tells Node.js to run the **same file** inside the worker
* The worker starts executing the file from the top

---

```js
  worker.on('message', (result) => {
    console.log(`Result from worker: ${result}`);
  });
```

* Listens for messages sent from the worker thread
* Messages are sent using `parentPort.postMessage()`
* Communication is **asynchronous** and **non-blocking**

---

```js
  worker.on('error', (error) => {
    console.error(`Worker error: ${error}`);
  });
```

* Handles runtime errors that occur inside the worker
* Without this, worker errors may crash silently

---

```js
  worker.on('exit', (code) => {
    if (code !== 0)
      console.error(`Worker stopped with exit code ${code}`);
  });
```

* Listens for worker termination
* Non-zero exit codes indicate abnormal termination

---

```js
} else {
```

* This block runs **inside the worker thread**
* `isMainThread` is `false` here

---

```js
  let sum = 0;
```

* Initializes a variable for computation
* This memory belongs exclusively to the worker thread

---

```js
  for (let i = 0; i < 1e9; i++) {
    sum += i;
  }
```

* Performs a CPU-intensive calculation
* This loop would **block the event loop** if run on the main thread
* Running in a worker prevents that blockage

---

```js
  parentPort.postMessage(sum);
```

* Sends the computed result back to the main thread
* Uses structured cloning (or transferable objects if configured)
* No shared mutable memory by default

---

## Interview-Ready One-Line Summary

> Worker threads in Node.js enable true parallel execution of CPU-bound JavaScript by offloading heavy computation to separate threads, preventing event-loop blocking while maintaining a single process architecture.
