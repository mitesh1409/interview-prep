# Promises in Node.js

## Writing asynchronous code with callbacks

Callbacks are the traditional way to write asynchronous code in JavaScript and Node.js. A callback is a function that is passed as an argument to another function and is executed after some operation has been completed. For example, when you read a file using the fs module in Node.js, you can pass a callback function that will be called once the file has been read.

## Problem with callbacks - Callback Pyramid of Doom or Callback Hell

Callbacks are fine upto one level of nesting, but when we have multiple levels of nesting, it becomes difficult to read and maintain the code. This is known as Callback Hell or Callback Pyramid of Doom.

## Promises to the rescue - Avoiding Callback Hell

Promises are a new feature in JavaScript as of ES6. Promises are part of JavaScript and they provide "native" way of writing/handling Asynchronous code in JavaScript.

Reference:
[How does Node.js handles asynchronous operations? OR Callbacks, Promises, async-await in Node.js](https://github.com/mitesh1409/interview-prep/blob/main/Node.js/Q-1771585486291.md)

## What are Promises in Node.js? Different states of a Promise

A promise is an object that may produce a single value some time in the future. Either a resolved value, or a reason that it is not resolved (rejected).

A promise can be in any one of the following stats:

Pending  
Resolved/Fulfilled  
Rejected  
Settled  

## Anatomy of a Promise - Producer and Consumer of a Promise

**Producer**  
When constructed Promise starts off in a Pending state.
It is developer's job to define a callback function called an executor function
which is passed to Promise constructor.
This executor function defines whether to resolve or reject the promise,
it will contain asynchronous code.

**Consumer**  
Consumer of the Promise can call its `.then`/`.catch`/`.finally` method.
It waits for the Promise to be settled (either resolved or rejected).
`.then` = function that handles fulfilment or resolved promise, receives value
`.catch` = function that handles rejection or rejected promise, receives error
`.finally` = function that handles settled promise, it allows to do cleanup at the end.

## Uber ride request example using Promise

Lets take an example of requesting an Uber ride.  

When you request a ride,  
the driver makes a promise to pick you up.  
While you are waiting the ride is pending.  

So initially a promise is in "Pending" state.

In the future if all goes according to plan  
the driver will resolve/fulfill the promise to pick you up,  
then take you to your destination,  
at this point your ride request has been resolved/fulfilled.

Promise is in "Resolved"/"Fulfilled" state.

But in some cases, the driver might reject your ride.  
And then you need to raise another request for a ride.  

Promise is in "Rejected" state.

So a Promise will be either "Resolved" or "Rejected".  
Either way the original request is now finally settled.

Promise is in "Settled" state.

```javascript
console.log('Start');

// Producer
const rideRequest = new Promise((resolve, reject) => {
    console.log('Promise > Executor function started...');

    const driverArrived = false;

    if (!driverArrived) {
        // We can pass any value, object into the reject function.
        // Generally we will pass an Error object, which contains reasons for failure.
        reject(new Error('No ride available at the moment. Please try again.'));
        console.log('Promise > Executor function finished > rejected');
    }

    const rideDetails = {
        from: 'From',
        to: 'To',
        driver: 'Driver Name',
        vehicle: {
            type: 'Car',
            number: 'IN-1234',
        },
        code: '9898',
    };

    resolve(rideDetails);

    console.log('Promise > Executor function finished > resolved');
});

console.log('rideRequest', rideRequest);

// Consumer
rideRequest
    .then(result => console.log('resolved result', result))
    .catch(error => console.error('rejected error', error))
    .finally(() => console.log('Ride request finally settled!'));

console.log('End');
```

## A Promise can only be settled once

A Promise can only be settled once — whichever comes first (resolve or reject) wins,  
and all subsequent calls are silently ignored.

This is by design in the Promise specification.

### Why this happens

Once a Promise transitions from `pending` to either `fulfilled` or `rejected`,  
it's **immutable** — its state is locked. There's no way to re-settle it.

```
pending  →  fulfilled  (terminal, cannot change)
pending  →  rejected   (terminal, cannot change)
```

### The "return" Best Practice

The better approach is to `return` after settling, to make the intent explicit and avoid confusion:  

Example: Bad code. Without `return`, the code after `resolve()` or `reject()` still runs, which can lead to unintended side effects or confusion.

```javascript
console.log('Start');

const aPromise = new Promise((resolve, reject) => {
    console.log('Promise executor started...');

    const success = true;

    if (success) {
        resolve('Success'); // the code below this will still run, which can be confusing
    }

    reject(new Error('Failed to resolve'));

    console.log('Promise executor finished...');
});

console.log('aPromise', aPromise);

aPromise
    .then(result => console.log('Resolved with value', result))
    .catch(error => console.error('Rejected with error', error))
    .finally(() => console.log('Finally promise is settled.'));

console.log('End');
```

Output for `const success = true;`

```
Start
Promise executor started...     // executor runs synchronously
Promise executor finished...    // still runs even after resolve()
aPromise Promise { 'Success' }  // aPromise already fulfilled by this line
End                             // synchronous code finishes first
Resolved with value Success     // .then() callbacks are microtasks, run after
Finally promise is settled.     // .finally() runs after .then()/.catch()
```

Output for `const success = false;`

```
Start
Promise executor started...
Promise executor finished...
aPromise Promise {
  <rejected> Error: Failed to resolve
      at /Users/mitesh_prajapati/js-apps/js-examples/examples/12/example-3.js:12:12
      at new Promise (<anonymous>)
      ...
}
End
Rejected with error Error: Failed to resolve
    at /Users/mitesh_prajapati/js-apps/js-examples/examples/12/example-3.js:12:12
    at new Promise (<anonymous>)
    ...
Finally promise is settled.
```

---

Example: Good code. With `return`, the code after `resolve()` or `reject()` won't run, which is cleaner and more efficient.

```javascript
console.log('Start');

const aPromise = new Promise((resolve, reject) => {
    console.log('Promise executor started...');

    const success = true;

    if (success) {
        return resolve('Success'); // the code below this will still run, which can be confusing
    }

    reject(new Error('Failed to resolve'));

    console.log('Promise executor finished...');
});

console.log('aPromise', aPromise);

aPromise
    .then(result => console.log('Resolved with value', result))
    .catch(error => console.error('Rejected with error', error))
    .finally(() => console.log('Finally promise is settled.'));

console.log('End');
```

Output for `const success = true;`

```
Start
Promise executor started...
aPromise Promise { 'Success' }
End
Resolved with value Success
Finally promise is settled.
```

Output for `const success = false;`

```
Start
Promise executor started...
aPromise Promise {
  <rejected> Error: Failed to resolve
      at /Users/mitesh_prajapati/js-apps/js-examples/examples/12/example-3.js:13:19
      at new Promise (<anonymous>)
      ...
}
End
Rejected with error Error: Failed to resolve
    at /Users/mitesh_prajapati/js-apps/js-examples/examples/12/example-3.js:13:19
    at new Promise (<anonymous>)
    ...
Finally promise is settled.
```

Without `return`, the code after `resolve()` still executes.  
The executor function runs to completion regardless — it's just that the extra `resolve`/`reject` calls  
have no effect on the Promise state. But returning early is cleaner and signals to other developers  
that the path ends there.

---

The executor function itself is **synchronous** — it runs immediately when you write `new Promise(...)`.  
That's why you see both executor logs before `aPromise` is printed.  
But the `.then()`, `.catch()`, and `.finally()` callbacks are **microtasks** —  
they're queued and run after the current synchronous code finishes,  
which is why `'End'` appears before `'Resolved with value Success'`.

## Delay with a Promise

```javascript
// Delay with a promise
function delay(ms) {
    return new Promise((resolve, reject) => {
        setTimeout(() => resolve(), ms);
    });
}

delay(3000)
    .then(() => console.log('Hello'));
```

## Promise callbacks and Event Loop

Promise callbacks are pushed to Microtask/Priority Queue.
It gets priority over Macrotask/Task Queue.

Reference:  

* [Order of Execution of a Node.js Application](https://github.com/mitesh1409/interview-prep/blob/main/Node.js/Q-1771585333788.md)
* [Explain Node.js Architecture](https://github.com/mitesh1409/interview-prep/blob/main/Node.js/Q-1771584411283.md)

## Promises parallel, sequence & race execution

Reference:

* [How would you handle multiple asynchronous calls efficiently? OR Promises parallel, sequence & race execution.](https://github.com/mitesh1409/interview-prep/blob/main/Node.js/Q-1771601292399.md)
