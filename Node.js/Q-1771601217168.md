# How do you handle errors in asynchronous code? Provide examples.

Lets understand with an example —  

* reading a file
* processing its content
* saving the result

## 1. Callbacks — Pyramid of Doom

```javascript
const fs = require('fs');

fs.readFile('input.txt', 'utf8', function(err, data) {
  if (err) {
    console.error('Error reading file:', err);
  } else {
    // nested inside readFile
    fs.writeFile('output.txt', data.toUpperCase(), function(err) {
      if (err) {
        console.error('Error writing file:', err);
      } else {
        // nested inside writeFile
        fs.readFile('output.txt', 'utf8', function(err, result) {
          if (err) {
            console.error('Error reading output:', err);
          } else {
            console.log('Final content:', result);
            // imagine more nesting here...
          }
        });
      }
    });
  }
});
```

Error handling is repeated at every level

---

## 2. Promises — Flat Chain

Node.js has a `promises` version of `fs` built-in (`fs.promises`), so no manual wrapping needed here.

```javascript
const fs = require('fs').promises;

fs.readFile('input.txt', 'utf8')
  .then(data => {
    return fs.writeFile('output.txt', data.toUpperCase());
  })
  .then(() => {
    return fs.readFile('output.txt', 'utf8');
  })
  .then(result => {
    console.log('Final content:', result);
  })
  .catch(err => {
    // one single place to handle ALL errors from any step above
    console.error('Something went wrong:', err);
  })
  .finally(() => {
    // Clean-up goes here...
  });
```

A single `.catch()` handles errors from any step in the chain

---

## 3. async/await — Looks Like Synchronous Code

`async/await` is just syntactic sugar built on top of Promises. Under the hood it's still Promises, just written in a way that *reads* like synchronous code.

```javascript
const fs = require('fs').promises;

async function processFile() {
  try {
    const data = await fs.readFile('input.txt', 'utf8');       // waits here
    await fs.writeFile('output.txt', data.toUpperCase());      // waits here
    const result = await fs.readFile('output.txt', 'utf8');    // waits here
    console.log('Final content:', result);
  } catch (err) {
    // handles errors from any awaited call above
    console.error('Something went wrong:', err);
  }
}

processFile();
```

`try/catch` feels natural — same error handling you'd use for synchronous code

---

## Key Takeaway

| | Callbacks | Promises | async/await |
|---|---|---|---|
| Shape | Nested pyramid | Flat chain | Linear/sequential |
| Error handling | Per callback | Single `.catch()` | Single `try/catch` |
| Readability | Poor at scale | Good | Best |
| Under the hood | Raw callbacks | Promise API | Promise API |
