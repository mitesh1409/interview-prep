# What are Event, Event Handler/Listener, Event Emitter, Event Queue, Event Loop, Event Driven?

## 1. Core Event Terminology ðŸ’¡

### Event

An **Event** is an action or occurrence that happens in the system. These can be internal or external.

**Examples:**  

* a user connecting to the server
* a file finishing a read operation
* a timer expiring
* data being received over a network

etc.

### Event Handler / Event Listener

The **Event Handler** or **Event Listener** is a **callback function** that is executed when a specific event occurs.

**Purpose:**  
It contains the logic the program should execute in response to the event. For example, when a 'data received' event occurs, the handler processes that data.

### Event Emitter

The **Event Emitter** is the core class in Node.js that enables the **Event-Driven Architecture**. Objects that emit events are instances of the `EventEmitter` class.

**Mechanism:**  
It provides methods like  
* `emitter.on(eventName, listener)` to register listeners, they will be executed once event occurs/happens
* `emitter.emit(eventName, [args])` to emit/fire/trigger an event

Reference:  
[The Node.js Event emitter](https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter)

### Event Driven

**Event Driven** is an **architectural pattern** where the flow of a program is determined by events. Instead of executing code sequentially, the program waits for events to occur and then runs the appropriate handler/listener function (callback).

**Benefit in Node.js:**  
It is the foundation of Node.js's non-blocking nature, allowing it to handle many operations concurrently without needing multiple threads.

---

## 2. Event Queue, Event Loop, and Node.js Architecture

The **Event Queue** and the **Event Loop** are the mechanisms that make the asynchronous, event-driven nature of Node.js possible.

### Event Queue (or Callback Queue)

The **Event Queue** is a simple data structure (specifically, a **FIFO Queue**) that holds all the **callback functions** (Event Handlers) that are ready to be executed.

**How it Works:**  
When an asynchronous operation (like reading a file) completes, its associated callback function is placed into the Event Queue/Callback Queue.  
The Event Loop then picks up these callbacks one by one.

### Event Loop

The **Event Loop** is the mechanism that allows Node.js to perform **non-blocking I/O operations** despite the fact that JavaScript itself is single-threaded. 

* **Its Role:** It's a continuous process that checks two things:
    1. The main **Call Stack** (where synchronous code executes) - is it free/empty?
    2. The **Event Queue** (where pending callbacks wait) - is there any callback?
* **The Single Rule:** If the Call Stack is empty (meaning the current synchronous code block has finished executing), the Event Loop takes the first callback from the Event Queue and pushes it onto the Call Stack for execution.

**IMP NOTE:**  
Global Execution Context (GEC) behavior:  
The Global Execution Context remains on the call stack throughout the entire lifecycle of your Node.js script. When we say "call stack is empty" in the context of the Event Loop, we mean:  

Empty = Only the Global Execution Context remains  
All other function execution contexts have been popped off  
No synchronous code is currently executing  

### Fitting into Node.js Architecture

* **V8 (The Engine):** Executes the synchronous JavaScript code on the Call Stack.
* **libuv (The Library):** Manages the **Event Loop** and handles all the **asynchronous I/O operations** (like network requests, file access). When an I/O operation finishes, `libuv` places the completion callback into the Event Queue.

---

## 3. Event Queue within the Event Loop Phases

The Node.js Event Loop is actually divided into **multiple phases**, each having its own internal queue. The Event Loop cyclically moves through these phases, executing callbacks from the corresponding phase's queue.

The **Event Queue** conceptually refers to all these phase-specific queues combined, waiting to be processed by the Event Loop.  
Event Queue = All the queues of the phases of the Event Loop  

Here is where the general "Event Queue" fits within the detailed phases of the Event Loop:

| Phase | Queue Name | Where the "Event Queue" callbacks fit |
| :--- | :--- | :--- |
| **timers** | Timer Queue | Holds callbacks for `setTimeout()` and `setInterval()` that have expired. |
| **pending callbacks** | Pending Queue | Executes system-level callbacks for certain OS operations (rarely used by developers). |
| **idle, prepare** | *(Internal)* | Used for internal libuv operations. |
| **poll** | **I/O Callback Queue** | This is the main place for most **I/O callbacks** (e.g., file system, network, TCP sockets). The Event Loop will *block* in this phase if there are no pending timers or `check` callbacks, waiting for I/O events to complete. |
| **check** | **Check Queue** | Holds callbacks for `setImmediate()`. |
| **close callbacks** | Close Queue | Handles callbacks for close events (e.g., `socket.on('close', ...)`). |

**In summary:**  
The **Event Queue** in the context of the Event Loop phases - the general concept of the **Event Queue** is split into several **phase-specific queues** (like the **I/O Callback Queue** in the **poll** phase or the **Check Queue**). The **poll phase** is where the majority of standard asynchronous I/O callbacks reside.

---

**IMP NOTE:**  

Starting with libuv 1.45.0 (Node.js 20), the event loop behavior changed  
to run timers only after the poll phase, instead of both before and after  
as in earlier versions. This change can affect the timing of setImmediate()  
callbacks and how they interact with timers in certain scenarios.

Reference  
[The Node.js Event Loop](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick)
