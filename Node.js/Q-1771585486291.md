# How does Node.js handles asynchronous operations? OR Callbacks, Promises, async-await in Node.js

Node.js handles asynchronous operations using:  

* Callbacks: A function is passed as an argument, and it will execute once the task is completed or event occurs
* Promises: A promise is an object that may produce a single value some time in the future - either a resolved value, or a reason that it is not resolved (rejected).
* Async/Await: Syntactic sugar over promises for better readability.

---

## Callbacks -> Promises -> async-await Evolution

1. We start with writing "Callbacks" for asynchronous code.  
2. Then we found a problem with "Nested Callbacks" - "Callback Pyramid of Doom".  
3. Solution is to use Promises.  
4. async-await (syntactic sugar for Promises) makes it even better, code looks like synchronous.

Lets understand with an example —  

* reading a file
* processing its content
* saving the result

---

## 1. Callbacks — Pyramid of Doom

```javascript
const fs = require('fs');

fs.readFile('input.txt', 'utf8', function(err, data) {
  if (err) {
    console.error('Error reading file:', err);
  } else {
    // nested inside readFile
    fs.writeFile('output.txt', data.toUpperCase(), function(err) {
      if (err) {
        console.error('Error writing file:', err);
      } else {
        // nested inside writeFile
        fs.readFile('output.txt', 'utf8', function(err, result) {
          if (err) {
            console.error('Error reading output:', err);
          } else {
            console.log('Final content:', result);
            // imagine more nesting here...
          }
        });
      }
    });
  }
});
```

**Problems:**  
- Every async step nests deeper — the "pyramid" shape
- Error handling is repeated at every level
- Hard to read, maintain, or reason about the flow
- Adding more steps makes it exponentially worse

---

## 2. Promises — Flat Chain

Node.js has a `promises` version of `fs` built-in (`fs.promises`), so no manual wrapping needed here.

```javascript
const fs = require('fs').promises;

fs.readFile('input.txt', 'utf8')
  .then(data => {
    return fs.writeFile('output.txt', data.toUpperCase());
  })
  .then(() => {
    return fs.readFile('output.txt', 'utf8');
  })
  .then(result => {
    console.log('Final content:', result);
  })
  .catch(err => {
    // one single place to handle ALL errors from any step above
    console.error('Something went wrong:', err);
  })
  .finally(() => {
    // Clean-up goes here...
  });
```

**Improvements:**  
- Flat `.then()` chain instead of nested callbacks
- A single `.catch()` handles errors from any step in the chain
- Each `.then()` receives the resolved value of the previous Promise
- Much easier to add or remove steps

---

## 3. async/await — Looks Like Synchronous Code

`async/await` is just syntactic sugar built on top of Promises. Under the hood it's still Promises, just written in a way that *reads* like synchronous code.

```javascript
const fs = require('fs').promises;

async function processFile() {
  try {
    const data = await fs.readFile('input.txt', 'utf8');       // waits here
    await fs.writeFile('output.txt', data.toUpperCase());      // waits here
    const result = await fs.readFile('output.txt', 'utf8');    // waits here
    console.log('Final content:', result);
  } catch (err) {
    // handles errors from any awaited call above
    console.error('Something went wrong:', err);
  }
}

processFile();
```

**Improvements over Promises:**  
- Reads top-to-bottom like synchronous code
- `await` pauses execution inside the `async` function until the Promise resolves
- `try/catch` feels natural — same error handling you'd use for synchronous code
- Variables like `data` and `result` are just local variables, no chaining needed

---

## Key Takeaway

| | Callbacks | Promises | async/await |
|---|---|---|---|
| Shape | Nested pyramid | Flat chain | Linear/sequential |
| Error handling | Per callback | Single `.catch()` | Single `try/catch` |
| Readability | Poor at scale | Good | Best |
| Under the hood | Raw callbacks | Promise API | Promise API |

`async/await` didn't replace Promises — it's built on them. Knowing how Promises work is essential to understanding `async/await` behavior.
