# Order of Execution of a Node.js Application

## High Level (Overview of the steps involved)

At a high level, the execution of a Node.js application can be understood in **three major layers**, executed in a specific order:

### 1. Application Startup & Synchronous Execution

* Node.js starts a **single process** with a **single main thread**
* JavaScript engine executes **all top-level synchronous code**
* Modules are loaded and executed
* Asynchronous operations are **registered**, not executed

### 2. Microtask Execution (High Priority Async)

* `process.nextTick` callbacks run
* Promise / `async-await` callbacks run
* These run **before** the event loop phases

### 3. Event Loop Execution (Asynchronous Callbacks)

* libuvâ€™s **event loop** starts
* Asynchronous callbacks are executed in **phases**
* Event loop keeps running until there is no more work

---

## Low Level (Details of each step)

---

## Step 1: Node.js Process Creation

* Node.js creates an **OS process**
* This process runs on **one main thread**
* This thread executes JavaScript
* This is often called the **main thread**, but internally it is managed by:

  * **V8** (JavaScript execution)
  * **libuv** (event loop, async I/O, thread pool)

---

## Step 2: Initialization Phase

During startup, Node.js initializes:

* V8 JavaScript engine
* libuv event loop
* Internal APIs (fs, timers, http, etc.)
* Global objects (`global`, `process`, `Buffer`, etc.)

### JavaScript perspective:

* **Global Execution Context is created**
* Memory allocation phase happens

  * Functions and variables are allocated memory
  * Code is not executed yet

---

## Step 3: Top-Level Synchronous Code Execution

### What is top-level code?

* Code **not inside any function or callback**
* Code inside the **Global Execution Context**

Example:

```js
console.log("Start");

setTimeout(() => {
  console.log("Timer");
}, 0);

console.log("End");
```

### What happens?

* JavaScript engine executes code **line by line**
* Synchronous statements run immediately
* Asynchronous APIs are **registered**, not executed

At this stage:

* Global Execution Context **execution phase** is completed

---

## Step 4: Module Loading and Execution

* `require()` (CommonJS) or `import` (ESM) modules are:

  * Loaded
  * Parsed
  * Executed synchronously
* Each module has its **own execution context**
* Module code runs **before** the event loop starts

---

## Step 5: Registration of Asynchronous Callbacks

When async code is encountered:

| API                         | What happens                       |
| --------------------------- | ---------------------------------- |
| `setTimeout`, `setInterval` | Registered with libuv timers       |
| `fs`, `http`, `crypto`      | Delegated to OS or thread pool     |
| Promises                    | Callback stored in microtask queue |
| `process.nextTick`          | Callback stored in nextTick queue  |

âš ï¸ **Important**

> Asynchronous code is NOT executed here â€” only registered.

---

## Step 6: `process.nextTick` Queue Execution

* `process.nextTick` is **not part of the event loop**
* Node.js maintains a **nextTick queue**
* This queue has the **highest priority**

Rules:

* Executes **after current JS stack**
* Executes **before promises**
* Can starve the event loop if misused

Order:

```
Call Stack â†’ nextTick Queue â†’ Microtask Queue â†’ Event Loop
```

---

## Step 7: Promise Microtask Queue Execution

Includes:

* `.then()`, `.catch()`, `.finally()`
* `async/await`

Characteristics:

* Not part of event loop phases
* Executed:

  * After `process.nextTick`
  * Before moving to next event loop phase
* Drained **completely** before continuing

---

## Step 8: Event Loop Starts (libuv)

Once:

* Call stack is empty
* `nextTick` queue is empty
* Microtask queue is empty

ðŸ‘‰ **libuv event loop starts**

---

## Step 9: Event Loop Phases (Execution Order)

The event loop runs in **phases**, repeatedly:

### Event Loop Phases Order

1. **Timers**

   * `setTimeout`
   * `setInterval`

2. **Pending Callbacks**

   * Some system-level callbacks (e.g., TCP errors)

3. **Idle, Prepare**

   * Internal use (Node.js internals)

4. **Poll**

   * Fetch new I/O events
   * Execute I/O callbacks (fs, network)
   * Can block here waiting for I/O

5. **Check**

   * `setImmediate` callbacks

6. **Close Callbacks**

   * `socket.on('close')`, cleanup callbacks

---

## Important Node.js 20+ Change (libuv â‰¥ 1.45.0)

Starting with **Node.js 20**:

* **Timers are no longer run before poll**
* Timers run **only after poll**
* This affects:

  * Ordering between `setTimeout(0)` and `setImmediate()`
  * Timing-sensitive code

---

## Who Handles What?

| Responsibility       | Component              |
| -------------------- | ---------------------- |
| JavaScript execution | V8                     |
| Synchronous code     | V8                     |
| Promise microtasks   | V8                     |
| `process.nextTick`   | Node.js                |
| Event loop           | libuv                  |
| Async I/O            | OS/libuv thread pool   |

---

## Final Simplified Execution Flow

```
1. Node process starts
2. Global execution context created
3. Top-level synchronous code runs
4. Modules execute
5. Async callbacks registered
6. process.nextTick queue runs
7. Promise microtask queue runs
8. Event loop starts
9. Event loop phases execute repeatedly
10. Process exits when no work remains
```
