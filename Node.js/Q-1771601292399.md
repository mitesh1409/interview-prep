# How would you handle multiple asynchronous calls efficiently?

Using promises we can handle multiple asynchronous calls efficiently in Node.js.

**3 ways to execute Promises**  

Promises can be executed in 3 ways  

1. Parallel
2. Sequencial
3. Race

## #1 Parallel

`Promise.all()`  
Promises execute in parallel to each other.  

Scenario #1 - All the promises are resolved.  
`Promise.all()` callback will be executed once all of them finishes their execution.  

Scenario #2 - One of the promises is rejected.  
`Promise.all()` callback will be executed once one of them is rejected.  
Short circuiting happens in this case, it does not wait for other promises to finish their execution.  

`Promise.allSettled()`  
Promises execute in parallel to each other.  
All the promises are settled - `Promise.allSettled()` callback will be executed once all of them finishes their execution regardless of their status (resolved/rejected).  
Unlike `Promise.all()`, `Promise.allSettled()` does not short circuit when one of the promises is rejected, it waits for all the promises to finish their execution regardless of their status (resolved/rejected).

Example: Parallel execution of promises using `Promise.all()`.

```javascript
const aResolvedPromise = (item, delay) =>
            new Promise((resolve, reject) =>
                setTimeout(
                    () => resolve(item), delay
                )
            );

const aRejectedPromise = (item, delay) =>
            new Promise((resolve, reject) =>
                setTimeout(
                    () => reject(item), delay
                )
            );

async function parallelPromises() {
    // All the promises are resolved.
    const promises = [
        aResolvedPromise('One', 1000),
        aResolvedPromise('Two', 2000),
        aResolvedPromise('Three', 3000)
    ];

    // // One of the promises is rejected.
    // const promises = [
    //     aResolvedPromise('One', 1000),
    //     aRejectedPromise('Zero', 10),
    //     aResolvedPromise('Two', 2000),
    //     aResolvedPromise('Three', 3000)
    // ];

    try {
        const result = await Promise.all(promises);
        return result.join();
    } catch (err) {
        console.log('Error: ', err);
        return err;
    }
}

parallelPromises()
    .then(
        (data) => console.log('parallelPromises output >>', data)
    );

console.log('Last line...');
```

Example: Parallel execution of promises using `Promise.allSettled()`.

```javascript
const promiseOne = new Promise((resolve, reject) =>
    setTimeout(() => resolve('Resolved promiseOne :)'), 1000)
);

const promiseTwo = new Promise((resolve, reject) =>
    setTimeout(() => reject('Rejected promiseTwo :('), 100)
);

const promiseThree = new Promise((resolve, reject) =>
    setTimeout(() => resolve('Resolved promiseThree :)'), 3000)
);

// // This will short circuit as soon as one of the promises is rejected, it does not wait for other promises to finish their execution.
// Promise.all([promiseOne, promiseTwo, promiseThree])
//     .then((data) => console.log(data))
//     .catch((err) => console.log('Failed to resolve a Promise. Error!', err));

// This will not short circuit, it waits for all the promises to finish their execution regardless of their status (resolved/rejected).
Promise.allSettled([promiseOne, promiseTwo, promiseThree])
    .then((data) => console.log('all promises settled!', data))
    .catch((err) => console.log('Failed to resolve a Promise. Error!', err));
```

**`all()` vs `allSettled()`**  
`allSettled()` in promises is part of ES2020.  

When all the promises inside `Promise.all` are resolved, it executes the callback in `then`.  
If anyone of them fails then it executes the callback in `catch`.  

When all the promises inside `Promise.allSettled` are settled, it executes the callback in `then`.  

When promise finishes its execution it can be in either Fulfilled/Resolved or Rejected status,  
and we say that the promise is settled now, it is no more in Pending status.  
When a promise is settled, it can be in either Fulfilled or Rejected status.  

`allSettled()` executes all the promises regardless of their status,  
it gives chance to execute all of the promises.  
Whereas `all()` finishes (short circuits) as soon as one of the promises failed to resolve.  

`allSettled()` returns an array of settled promises.  
When all of the promises resolved `all()` returns an array of result of the resolved promises,  
if one or more promises are rejected then `all()` executes catch block to handle failure  
or throws an exception if catch block is not present.  

## #2 Sequencial

Promises execute in sequence, one after the other.  

Scenario #1 - All the promises are resolved.  
Callback will be executed once all of them finishes their execution.  

Scenario #2 - One of the promises is rejected.  
Callback will be executed once one of them is rejected.  
Short circuiting happens in this case, it does not wait for other promises to finish their execution.  

Example: Sequencial execution of promises using async/await.  

```javascript
const aResolvedPromise = (item, delay) =>
            new Promise((resolve, reject) =>
                setTimeout(
                    () => resolve(item), delay
                )
            );

const aRejectedPromise = (item, delay) =>
            new Promise((resolve, reject) =>
                setTimeout(
                    () => reject(item), delay
                )
            );

async function sequencialPromises() {
    try {
        // One of the promises is rejected.
        const output1 = await aResolvedPromise('One', 1000);   // first this
        const output2 = await aRejectedPromise('Two', 10);     // then this
        const output3 = await aResolvedPromise('Three', 3000); // then this?

        // All the promises are resolved.
        // const output1 = await aResolvedPromise('One', 1000);   // first this
        // const output2 = await aResolvedPromise('Two', 2000);   // then this
        // const output3 = await aResolvedPromise('Three', 3000); // then this
        return `${output1}, ${output2}, ${output3}`;
    } catch (error) {
        console.error('Error', error);
        return error;
    }
}

const sequencialPromisesOutput = await sequencialPromises();
console.log('await sequencialPromises() output >>', sequencialPromisesOutput);

console.log('Last line...');
```

## #3 Race

`Promise.race()`  
Technically all Promises will start at the same time, they run in parallel.  
Hence there is a race, the one which finishes first is a winner.  
As soon as one of the Promises finishes first (resolved or rejected), callback will be executed,  
it does not wait for other promises to finish their execution.  

Example: Execution of promises using `Promise.race()`.  

```javascript
const aResolvedPromise = (item, delay) =>
            new Promise((resolve, reject) =>
                setTimeout(
                    () => resolve(item), delay
                )
            );

const aRejectedPromise = (item, delay) =>
            new Promise((resolve, reject) =>
                setTimeout(
                    () => reject(item), delay
                )
            );

async function racePromises() {
    // All the promises are resolved.
    const promises = [
        aResolvedPromise('One', 1000),
        aResolvedPromise('Two', 2000),
        aResolvedPromise('Three', 3000)
    ];

    // // One of the promises is rejected.
    // const promises = [
    //     aResolvedPromise('One', 1000),
    //     aRejectedPromise('Zero', 10),
    //     aResolvedPromise('Two', 2000),
    //     aResolvedPromise('Three', 3000)
    // ];

    try {
        const result = await Promise.race(promises);
        return result;
    } catch (err) {
        console.log('Error: ', err);
        return err;
    }
}

racePromises()
    .then(
        (data) => console.log('racePromises output >>', data)
    );

console.log('Last line...');
```

---

## When to use what?

Parallel - `Promise.all()`  
When we want to execute all of the promises regardless of their order of execution  
then we should use "Parallel" method.  

Parallel - `Promise.allSettled()`  
When we want to execute all of the promises regardless of their order of execution  
and we want to know the status of each promise (resolved/rejected)  
then we should use "Parallel" method with `Promise.allSettled()`.  
It will not short circuit if one of the promises is rejected,  
it waits for all the promises to finish their execution regardless of their status (resolved/rejected).

Sequence  
If we want to execute all of the promises in a specific order, one after the other,  
then we should use "Sequence" method.

Race  
If we want to execute all of the promises but move forward with the one  
which finishes first then we should use "Race" method.

Except Parallel with `Promise.allSettled()`,  
all the other methods (Parallel with `Promise.all()`, Sequence and Race)  
short circuit when one of the promises is rejected,  
it does not wait for other promises to finish their execution.

---

## Parallel, Sequence, Race which one is the fastest?

Lets take an example,  
assume there are 3 promises - first, second, third.  
first takes 10 milli seconds, second takes 20 milli seconds & third takes 30 milli seconds to finish their execution.

When using Race, the first promise will be completed first,  
so it takes 10 milli seconds.

When using Parallel, all promises will execute in parallel,  
it will take at least 30 milli seconds.

When using Sequencial, all promises will execute one after the other,  
so it will take at least 10 + 20 + 30 = 60 milli seconds.

Race > Parallel > Sequence

Race is the fastest, then Parallel and then Sequence is the slowest.

---

## Is there a limit for how many promises can run in parallel?


### The "Parallel" Misconception

`Promise.all()`, `Promise.allSettled()`, and `Promise.race()` do **not** execute promises in parallel in the true sense. They execute them **concurrently**, which is different.

Here's the distinction:

- **Parallel** — multiple things literally running at the same time on multiple CPU cores/threads (true multi-threading)
- **Concurrent** — multiple things are *in progress* at the same time, but not necessarily executing simultaneously. They overlap in time by taking turns on a single thread.

Node.js is **single-threaded**. Your JavaScript code always runs on one thread. What makes it feel parallel is the **Event Loop** — when a Promise hits an async operation (like a network request or file read), Node.js hands it off to the underlying system (libuv) and moves on to start the next Promise. It doesn't sit and wait.

So with `Promise.all()`:

```javascript
const [a, b, c] = await Promise.all([
  fetch('url1'),  // handed off, Node moves on
  fetch('url2'),  // handed off, Node moves on
  fetch('url3'),  // handed off, Node moves on
]);
// Node now waits for all three to resolve
```

All three requests are *in-flight* at the same time — that's concurrency. But your JS thread isn't doing three things simultaneously.

---

### Is There a Limit?

Yes, but it's **not** determined by CPU cores (since JS is single-threaded). The limits come from:

**1. libuv thread pool** — For operations like file I/O, DNS lookups, crypto etc., Node uses libuv's internal thread pool. The default size is **4 threads**. So if you fire 100 `fs.readFile()` promises at once, only 4 will actually be processed at a time by the thread pool. You can increase this with the `UV_THREADPOOL_SIZE` environment variable (max 1024).

**2. OS/network limits** — For network requests, the OS limits how many open sockets/connections you can have. This varies by OS but is typically in the thousands.

**3. External service limits** — APIs often have rate limits, so bombarding them with 10,000 concurrent requests will get you throttled or blocked regardless of what Node can handle.

**4. Memory** — Each pending Promise holds state in memory. Thousands of unresolved Promises can cause memory pressure.

---

### Practical Takeaway

```javascript
// This fires ALL 10,000 requests at once — dangerous!
await Promise.all(urls.map(url => fetch(url)));

// Better — process in batches of, say, 10 at a time
// (you'd use a library like p-limit for this in real projects)
```

So in production, you rarely want to blindly throw everything into `Promise.all()` without thinking about how many operations you're kicking off. Libraries like **`p-limit`** or **`p-queue`** exist specifically to control concurrency — letting you say "run at most 10 of these at a time."

---

### Summary

| Myths | Reality |
|---|---|
| `Promise.all` runs in parallel | It runs **concurrently** on a single JS thread |
| Limit depends on CPU cores | Limit depends on **libuv thread pool, OS, memory, and external services** |

The distinction between *parallel* and *concurrent* is subtle but crucial in Node.js — it's the heart of understanding how the Event Loop works.
